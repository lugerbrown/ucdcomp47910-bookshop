\documentclass[]{UCD_CS_FYP_Report}
\usepackage{graphicx}
\usepackage{hyperref}

%%%%%%%%%%%%%%%%%%%%%%
%%% Input project details

\def\studentname{Luis Marron (23202882)} % Edit with your name
\def\projecttitle{{\linespread{4.5}\selectfont COMP47910 Secure Software Engineering}} % Edit with you project title
\def\supervisorname{Dr. Liliana Pasquale} % Edit with your supervisor name


\begin{document}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%
%%% Table of Content

\tableofcontents\pdfbookmark[0]{Table of Contents}{toc}\newpage
\newpage

%%%%%%%%%%%%%%%%%%%%%%
%%% Vulnerabilities Fixes Report


\chapter{A01:2021 Broken Access Control}


\section{CWE-284: Improper Access Control}

\textbf{Description}: The BookShop application implements improper access control mechanisms that allow unauthorized users to access restricted functionality and sensitive data. The application lacks proper authentication and authorization checks across multiple endpoints, enabling attackers to bypass security controls and gain unauthorized access to administrative functions and user-specific resources.

\textbf{CWE Explanation}: CWE-284 occurs when the application fails to properly restrict access to functionality or resources, allowing unauthorized users to perform actions or access data that should be protected by proper authentication and authorization mechanisms.

\textbf{Severity}: High

\subsection{Vulnerability Locations and Type}
The application suffered from multiple \textit{Broken / Improper Access Control} weaknesses manifesting as:
\begin{itemize}
	\item \textbf{Vertical privilege escalation}: Security rule protected path pattern \texttt{/admin/**}, while the actual admin endpoint controller was mapped to \texttt{/admins}. This mismatch let any authenticated non-admin invoke administrative endpoints (e.g. \texttt{GET /admins}).
	\item \textbf{Horizontal privilege escalation / Insecure Direct Object Reference (IDOR)}: Cart- and cart-itemâ€“related REST endpoints (\texttt{/carts/**}, \texttt{/cart-items/**}) accepted arbitrary \texttt{customerId}, \texttt{cartId}, or \texttt{itemId} without verifying ownership against the authenticated principal, enabling access/modification of other users' carts.
	\item \textbf{Over broad data exposure}: User and customer enumeration endpoints (\texttt{/users/**}, \texttt{/customers/**}) allowed any authenticated user to list or fetch other users/customers and (in the case of \texttt{/users}) returned password hashes, breaching least privilege and confidentiality.
	\item \textbf{Unrestricted modification endpoints}: Book management API (\texttt{books} \texttt{POST} \texttt{PUT} \texttt{DELETE}) was accessible to any authenticated role, permitting non-admin content manipulation.
	\item \textbf{Lack of server side authorization on web cart actions}: Web MVC endpoints for cart item removal did not assert ownership, allowing crafted requests to remove other users' items.
\end{itemize}

\subsection{Mitigation Strategy and Rationale}
Defence-in-depth was applied combining \textbf{path-based authorization}, \textbf{method-level role enforcement}, and \textbf{resource ownership (row-level) checks}. This layered approach ensures:
\begin{itemize}
	\item Misconfigurations in one layer (e.g. path patterns) do not automatically grant access because method-level annotations add a second gate.
	\item Even with correct role checks, horizontal attacks "guessing IDs" are blocked by explicit ownership validation tying domain object identifiers to the authenticated principal "prevents IDOR".
	\item Principle of Least Privilege is restored by scoping sensitive endpoints (admin, user lists, data mutations) strictly to the required roles, reducing attack surface.
	\item Sensitive credential fields are no longer exposed after authorization succeeds, limiting post-auth data leakage channels.
\end{itemize}

\subsection{Implemented Security Controls}
The following concrete changes were introduced in code (branch \texttt{broken-access-control-fixes}):
\begin{enumerate}
	\item \textbf{Corrected admin path mapping}: Updated Spring Security configuration to match the actual controller path \texttt{/admins/**} instead of the incorrect \texttt{/admin/**}.
	\item \textbf{Granular authorization rules}: Added HTTP method specific matchers restricting book mutation endpoints (POST/PUT/DELETE on \texttt{/api/books/**}) and all \texttt{/books/**} (management pages) to role \texttt{ADMIN}. User endpoints \texttt{/users/**} now require \texttt{ADMIN}; customer endpoints enforce authentication plus ownership (see point 3) and reserve modifications for \texttt{ADMIN}.
	\item \textbf{Ownership / row-level checks}: Injected \texttt{@AuthenticationPrincipal} into cart and cart item controllers; added helper methods validating that the referenced cart/item's owning customer's username equals the authenticated principal. Requests failing validation now return HTTP 403 (or 404 when appropriate).
	\item \textbf{Method-level security}: Enabled \texttt{@EnableMethodSecurity} and introduced \texttt{@PreAuthorize} annotations on controller methods (e.g. book mutations, user controller) to provide a second authorization layer beyond URL pattern matching.
	\item \textbf{Data minimisation via DTOs}: Replaced direct entity exposure for users and customers with DTOs omitting the password field and limiting attributes to non-sensitive identification data.
	\item \textbf{Cart web endpoint hardening}: Added ownership validation before allowing removal of a cart item via web MVC endpoint to block cross-user manipulation.
	\item \textbf{Input encapsulation}: Refactored mutable request payload classes (e.g. add-item request) to use private fields with accessors, preventing accidental uncontrolled field exposure (minor hardening).
\end{enumerate}

\subsection{Solution Effectiveness}
The mitigations directly address the CWE-284 root causes:
\begin{itemize}
	\item Path correction + role restrictions close vertical privilege escalation vectors.
	\item Ownership validation eliminates horizontal ID enumeration attacks by binding operations to the authenticated identity.
	\item Method-level annotations safeguard against future path mapping drift or overly broad ant matchers.
	\item DTO-based redaction removes unnecessary sensitive data from responses, shrinking impact radius of any residual access gaps.
	\item Principle of Least Privilege is enforced consistently across both REST and MVC layers, aligning actual access with business intent.
\end{itemize}



\section{CWE-639: Insecure Direct Object References }

	\textbf{Description}: Multiple endpoints previously trusted user-supplied identifiers (e.g. \texttt{customerId}, \texttt{cartId}, \texttt{itemId}) directly to select resources without verifying that the authenticated principal owned or was entitled to those resources. Attackers could substitute another valid numeric ID (IDOR) to read or modify other users' shopping cart contents or personal data.

	\textbf{CWE Explanation}: CWE-639 occurs when an application authorizes a request based solely on a user-controlled key (such as a record ID) instead of confirming the requester is permitted to access the referenced object, enabling horizontal privilege escalation (Insecure Direct Object Reference).

	\textbf{Severity}: High

\subsection{Vulnerability Locations and Type}
\begin{itemize}
	\item \textbf{Cart REST endpoints}: \texttt{/carts/by-customer/{customerId}}, \texttt{/carts/{cartId}/items}, \texttt{/carts/{cartId}/add-item}, \texttt{/carts/{cartId}/remove-item/{itemId}}, and \texttt{/carts/{cartId}/total-price} accepted arbitrary path IDs; prior to fixes there was no binding between these IDs and the authenticated user (classic IDOR / horizontal escalation).
	\item \textbf{Cart item endpoint}: \texttt{/cart-items/{id}} exposed individual cart items without verifying ownership (permitting enumeration of other users' items by ID).\newline
	\item \textbf{Customer lookup endpoints}: \texttt{/customers/{id}} and \texttt{/customers/by-username/{username}} allowed retrieval of other customers' personal information without ownership check (in early state) relying only on being authenticated.
\end{itemize}

\subsection{Mitigation Strategy and Rationale}
The strategy focused on eliminating trust in client-supplied identifiers by: (1) performing \textbf{server-side ownership validation} after object retrieval, (2) layering \textbf{role checks} so only admins can enumerate accounts, and (3) reducing exposed data via DTOs. Ownership checks ensure an attacker who guesses an ID still receives \texttt{403 Forbidden} (or \texttt{404 Not Found}) unless authorized. This halts horizontal privilege escalation while preserving legitimate functionality for rightful owners.

\subsection{Implemented Security Controls}
\begin{enumerate}
	\item \textbf{Ownership helpers}: Introduced methods \texttt{enforceCustomerOwnership(...)} and \texttt{resolvedOwnedCart(...)} in the cart controller to load the resource and verify \texttt{resource.owner.username == principal.username} before returning it.
	\item \textbf{Cart item deletion hardening}: Added explicit retrieval and cart-to-item linkage verification before deleting an item, ensuring the item belongs to the authenticated user's cart, preventing cross-cart deletions.
	\item \textbf{Principal injection}: Added \texttt{@AuthenticationPrincipal} parameters to affected controller methods to reliably access the authenticated identity rather than relying on user-provided IDs.
	\item \textbf{Customer data protection}: Added central ownership/admin check (\texttt{enforceOwnershipOrAdmin}) to customer endpoints and restricted full listing to \texttt{ADMIN} via \texttt{@PreAuthorize}.
	\item \textbf{Least privilege for enumeration}: Restricted \texttt{/users/**} and customer listing endpoints to \texttt{ADMIN} in \texttt{SecurityConfig}, removing the ability for regular users to guess IDs and enumerate.
	\item \textbf{DTO redaction}: Replaced direct entity exposure with DTOs omitting password hashes, limiting the value of any accidental disclosure.
	\item \textbf{Path-based + method security}: Retained path restrictions (role-based) and enabled method-level security, adding a secondary barrier should future path patterns broaden inadvertently.
\end{enumerate}

\subsection{Solution Effectiveness}
\begin{itemize}
	\item Ownership enforcement turns previously unauthenticated resource selection into a two-factor authorization (valid ID + rightful owner) neutralising ID guessing.
	\item Removal operations now validate item-to-cart ownership, closing a residual destructive IDOR vector.
	\item Admin-only enumeration eliminates bulk discovery of valid identifiers (reducing reconnaissance surface).
	\item DTO redaction ensures that even if an ownership check regresses, sensitive credential data remains undisclosed.
	\item Layered (config + method) checks reduce single-point-of-failure risk if URL matcher misconfiguration reappears.
\end{itemize}

\section{CWE-384: Session Fixation}

	\textbf{Description}: Initially the session fixation risk was assessed because the configuration did not explicitly state a session fixation protection strategy, and CSRF protection was disabled (increasing the impact of any session hijacking). However, Spring Security's default behaviour already migrates (rotates) the session identifier upon successful authentication. We have now made this protection explicit in the security configuration, confirming that an attacker who pre-seeds a victim with a known anonymous session ID cannot continue to use that same ID after the victim authenticates.

	\textbf{CWE Explanation}: CWE-384 (Session Fixation) concerns failure to invalidate or regenerate a session identifier when a user's authentication state changes, enabling an attacker who knows the pre-auth session token to hijack the post-auth session.

	\textbf{Severity}: Low (Residual) â€“ Effective mitigations in place; only hardening items remain.

\subsection{Vulnerability Locations and Type}
Prior to the explicit mitigation the potential exposure was theoretical rather than an observed exploit, characterised by:
\begin{itemize}
	\item No explicit session fixation directive in \texttt{SecurityConfig} (relying implicitly on framework defaults).\newline
	\item Disabled CSRF protection (would amplify damage of any successful fixation / hijack).\newline
	\item Absence of cookie security attribute configuration (Secure / SameSite / HttpOnly not yet declared in \texttt{application.properties}).
\end{itemize}
Crucially, there was \emph{no} custom code overriding Spring Security's default fixation protection; thus the core exploit path (reusing the same session ID after login) was already blocked.

\subsection{Mitigation Strategy and Rationale}
Strategy focused on: (1) making implicit framework protections \emph{explicit} for auditability, (2) reducing residual attack surface through planned cookie hardening and CSRF re-enablement, and (3) documenting session handling to prevent future regressions (e.g. switching to a stateless policy without compensating controls). Explicit configuration eliminates uncertainty for reviewers and compliance checks.

\subsection{Implemented Security Controls}
\begin{enumerate}
	\item \textbf{Explicit session ID migration}: Added \texttt{sessionFixation(migrateSession())} under \texttt{sessionManagement} in \texttt{SecurityConfig}, guaranteeing a new session identifier post-authentication.
	\item \textbf{Logout invalidation}: Existing logout configuration invalidates the session server-side, preventing reuse of an authenticated context.
	\item \textbf{Least privilege hardening elsewhere}: Reduced horizontal/vertical escalation (CWE-284 / CWE-639 controls) lowers the value of any hypothetical hijacked session.
	\item \textbf{Password hashing (BCrypt)}: Limits credential replay even if a session were short-livedly exposed.
\end{enumerate}

\subsection{Solution Effectiveness}
\begin{itemize}
	\item Attacker-controlled pre-auth session IDs are invalidated because the server issues a fresh session ID upon authentication (session fixation vector neutralised).
	\item Logout and privilege boundaries ensure compromised sessions cannot silently escalate or persist indefinitely.
	\item Strengthened access controls reduce the actionable scope of any transient session misuse.
	\item Making the protection explicit aids code reviews and prevents accidental regression (e.g. future refactor removing defaults unnoticed).
\end{itemize}

Given the default and now explicit migration behaviour, the application is not meaningfully vulnerable to session fixation at present; residual items are advisory enhancements.


\chapter{A02:2021 Cryptographic Failures}

\section{CWE-311: Missing Encryption of Sensitive Data}

	\textbf{Description}: Certain sensitive data flows in the BookShop application lack enforced cryptographic protection in transit or rely on plaintext representation in local configuration. While user passwords are securely hashed (BCrypt) and the application--database channel is configured for SSL, end-user credential submission (login/registration), session cookies, and ad hoc sensitive form fields (e.g. checkout credit card input) can traverse unencrypted HTTP if the deployment is not fronted by TLS. Additionally, example environment variables and scripts illustrate plaintext storage of database and truststore secrets. These gaps collectively represent incomplete protection of sensitive data rather than a single critical exposure.

	\textbf{CWE Explanation}: CWE-311 refers to missing or absent encryption for sensitive information either at rest or in transit where encryption is expected for confidentiality or regulatory compliance. It commonly manifests as cleartext transmission (overlaps with CWE-319) or cleartext storage (overlaps with CWE-312 / CWE-256) when mitigations are inconsistent or absent.

	\textbf{Severity}: Medium (Residual) -- Core credentials (passwords at rest) are protected; remaining issues affect transport and secret handling hygiene.

\subsection{Vulnerability Locations and Type}
\begin{itemize}
	\item \textbf{Transport (HTTP)}: Application lacks explicit HTTPS / TLS configuration (no \texttt{server.ssl.*}); README usage examples employ \texttt{http://localhost:8080}. In any non-local deployment without a reverse proxy TLS terminator, credentials and session cookies would be transmitted in cleartext (CWE-319 contributing to CWE-311).
	\item \textbf{Session Cookies}: No Secure, HttpOnly, or SameSite attributes configured; cookies could be exposed over insecure transport or be susceptible to CSRF replay.
	\item \textbf{Checkout form data}: Credit card number field (not persisted) is still transmitted; without TLS it is exposed in transit. No masking or client-side obfuscation.
	\item \textbf{Secrets in environment artifacts}: Example \texttt{.env} content and setup scripts contain plaintext database credentials and truststore password (acceptable for local dev, but a risk pattern if replicated to production). Overlaps with CWE-256.
	\item \textbf{Logging / auditing}: No explicit masking safeguards (currently no evidence of leakage, but absence of policy introduces latent risk if future logging is added).
\end{itemize}

\subsection{Mitigation Strategy and Rationale}
Strategy targets layered confidentiality protection: (1) enforce TLS for all external HTTP traffic; (2) harden session cookie attributes to reduce exposure and replay potential; (3) minimise plaintext secret footprint by moving production secrets to a managed vault; (4) restrict network attack surface via HSTS and secure redirects; (5) avoid collecting unnecessary high sensitivity data (drop credit card field if not processing payments). This layered defence ensures compromise of any single mechanism (e.g. proxy misconfiguration) does not fully expose sensitive data.

\subsection{Implemented / Planned Security Controls}
\begin{enumerate}
	\item \textbf{Password hashing (in place)}: All user credentials stored with BCrypt (adaptive hashing, salts implicit) -- removes cleartext password storage risk.
	\item \textbf{Encrypted DB channel (in place)}: JDBC URL enforces \texttt{useSSL=true} and \texttt{requireSSL=true} with truststore configuration.
	\item \textbf{Session fixation mitigation (in place)}: Protects session integrity post-auth (limits utility of intercepted pre-auth IDs).
	\item \textbf{Planned TLS enforcement}: Introduce reverse proxy or Spring Boot keystore; redirect HTTP\;$\rightarrow$\;HTTPS and add HSTS header.
	\item \textbf{Cookie hardening (planned)}: Set \texttt{server.servlet.session.cookie.secure=true}, \texttt{...http-only=true}, \texttt{...same-site=Strict}.
	\item \textbf{Secret management (planned)}: Replace plaintext env variables (especially root DB password) with secrets provisioned by a secure store (Vault / cloud KMS) and principle of least privilege DB accounts.
	\item \textbf{Data minimisation (planned)}: Remove or tokenise credit card field; if retained for demo, clearly flag as non-production and mask client-side.
	\item \textbf{Logging safeguards (planned)}: Introduce logging policy and filters to prevent future accidental sensitive data logging.
\end{enumerate}

\subsection{Solution Effectiveness}
\begin{itemize}
	\item Existing strong password hashing and encrypted DB transport already neutralise the most damaging storage and backend transit risks.
	\item Planned universal TLS and Secure/HttpOnly/SameSite cookies will close interception windows for credentials and session tokens.
	\item Secret manager adoption will reduce blast radius of host compromise or repo leakage versus static env files.
	\item Removing unnecessary high sensitivity fields (credit card) eradicates an entire sensitive data class, lowering compliance scope (PCI DSS) and exposure.
	\item Layered controls ensure that even if one layer (e.g. proxy TLS) fails, credential hashes remain non-reversible and session tokens protected by cookie policies.
\end{itemize}

\section{CWE-315: Cleartext Storage of Sensitive Information in a Cookie}

	\textbf{Description}: Analysis confirms no sensitive information (plaintext passwords, API keys, tokens containing secrets, PII, payment data) is stored in browser cookies. The application relies exclusively on the standard opaque \texttt{JSESSIONID} for server-side session tracking. No custom cookie creation exists in server code or client-side JavaScript; thus the application is \emph{not currently vulnerable} to CWE-315.

	\textbf{CWE Explanation}: CWE-315 covers placing sensitive information directly (cleartext or trivially encoded) into cookies such that disclosure or tampering enables account compromise, impersonation, or data leakage. Even with HTTPS, client-side storage of secrets is discouraged because local access or XSS can expose them.

	\textbf{Severity}: None (Not Vulnerable). Would elevate to High if future changes store secrets (e.g. raw bearer tokens) in cookies without encryption/integrity safeguards.

\subsection*{Assessment Evidence}
\begin{itemize}
	\item No occurrences of custom \texttt{Cookie} creation or header manipulation in Java sources.
	\item No \texttt{document.cookie} usage in static JS or templates.
	\item DTOs exclude password hashes; no credential material leaves server to be placed in cookies.
	\item Session identifier is opaque; no sensitive claims or data embedded.
\end{itemize}

\subsection*{Mitigation Strategy and Rationale}
Maintain a minimal opaque session token model: keep all sensitive state server-side; never persist secrets or PII in client cookies. Complement with cookie attribute hardening (Secure, HttpOnly, SameSite) and session rotation (already explicit) to reduce ancillary risks (CWE-614, CWE-1275) while ensuring no CWE-315 condition can emerge inadvertently.

\subsection*{Implemented / Planned Controls}
\begin{enumerate}
	\item \textbf{Opaque server session (implemented)}: Only an identifier stored client-side.
	\item \textbf{Password hashing (implemented)}: Removes any need to surface plaintext credentials.
	\item \textbf{No custom cookie writes (implemented)}: Eliminates common accidental leakage vector.
	\item \textbf{Cookie attribute hardening (planned)}: Add Secure / HttpOnly / SameSite (ties into CWE-319 remediation).
	\item \textbf{Future guardrails (planned)}: CI/static rule to flag introduction of sensitive keywords in cookie names or values.
\end{enumerate}

\subsection*{Solution Effectiveness}
\begin{itemize}
	\item Absence of data-bearing cookies removes primary CWE-315 attack surface.
	\item Planned attributes further reduce residual token theft or cross-site replay vectors.
	\item Guardrails lower regression risk if new auth features (remember-me, JWT) are introduced.
\end{itemize}


\section{CWE-319: Cleartext Transmission of Sensitive Information}

	\textbf{Description}: Client-server interactions (login, registration, authenticated browsing) were originally performed over HTTP with no transport security enforcement, as neither embedded TLS (no \texttt{server.ssl.*} properties) nor an HTTPS redirect existed. Documentation curl examples referenced \texttt{http://localhost:8080}, normalising plaintext usage. In any non-local / shared network scenario this exposes credentials and session identifiers to interception or manipulation (Man-in-the-Middle, passive sniffing). Session cookies also lacked Secure / SameSite attributes, increasing replay and cross-site leakage risk.

	\textbf{CWE Explanation}: CWE-319 addresses transmission of sensitive information over cleartext channels. Attackers positioned on the network path can read or alter traffic lacking cryptographic protection. This differs from CWE-311 (broader missing encryption) by focusing specifically on in-transit confidentiality/integrity compromise enabling credential theft, session hijacking, or data tampering.

	\textbf{Severity}: High (production / shared networks). Medium (loopback-only development) but still a negative security practice.

\subsection*{Vulnerability Locations and Type}
\begin{itemize}
	\item \textbf{No TLS configuration}: Absence of \texttt{server.ssl.key-store} or reverse proxy mandate meant HTTP only.
	\item \textbf{No enforcement}: Security configuration had no channel security requirement or redirect to HTTPS.
	\item \textbf{Session cookies}: Lacked Secure, HttpOnly, SameSite flags (susceptible to interception / CSRF replay once over HTTP).
	\item \textbf{Documentation examples}: README exclusively used plaintext HTTP endpoints, encouraging insecure operational patterns.
	\item \textbf{Potential sensitive forms}: Payment / PII form submissions (if added) would likewise traverse HTTP.
\end{itemize}

\subsection*{Mitigation Strategy and Rationale}
Enforce an \textit{HTTPS by default} posture: (1) introduce production-profile HTTPS enforcement and HSTS to prevent downgrade, (2) configure TLS via keystore or proxy, (3) harden cookies (Secure, HttpOnly, SameSite) reducing token exfiltration surface, (4) eliminate plaintext examples to shift developer behaviour, (5) add automated tests verifying redirect + security headers to prevent regression. Layered approach ensures that if a single control fails (e.g. misconfigured proxy), other safeguards (cookie flags, credential hashing) limit exploit value.

\subsection*{Implemented / Planned Security Controls}
\begin{enumerate}
	\item \textbf{Prod profile HTTPS enforcement (implemented)}: Added custom redirect filter + HSTS headers when \texttt{prod} profile active.
	\item \textbf{HSTS (implemented prod)}: Sets long max-age with subdomain + preload intent to resist protocol downgrades.
	\item \textbf{Password hashing (existing)}: Mitigates offline cracking impact if credentials were previously observed.
	\item \textbf{Cookie hardening (planned)}: Add \texttt{server.servlet.session.cookie.secure=true}, \texttt{...http-only=true}, \texttt{...same-site=Strict}.
	\item \textbf{TLS keystore / proxy integration (planned)}: Provide keystore properties or documented reverse proxy termination (NGINX / Caddy with ACME).
	\item \textbf{Documentation update (planned)}: Replace HTTP examples with HTTPS and describe trusting dev self-signed cert.
	\item \textbf{Automated tests (planned)}: Integration test asserting HTTP -> HTTPS 301/308 redirect and presence of HSTS in prod.
	\item \textbf{Mixed content audit (planned)}: Validate no HTTP asset references remain post-transition.
\end{enumerate}

\subsection*{Solution Effectiveness}
\begin{itemize}
	\item HTTPS enforcement + HSTS removes primary interception vector (passive sniffing / trivial MiTM downgrade).
	\item Cookie hardening will prevent session token leakage over inadvertent HTTP calls and reduce CSRF token reuse potential.
	\item Removing plaintext examples reduces operational drift toward insecure defaults.
	\item Automated testing creates a guardrail against accidental removal of channel security.
	\item Existing password hashing ensures historical captures have limited utility if obtained pre-mitigation.
\end{itemize}


\section{CWE-256: Unprotected Storage of Credentials}

	\textbf{Description}: Core user credentials (passwords) are securely stored using BCrypt hashing; however, residual unprotected credential storage issues remain: (1) a default administrator password is disclosed in cleartext inside the seeding script comments, (2) database and truststore secrets are managed as plaintext environment variables in a local \texttt{.env} file and referenced directly by docker compose, and (3) weak placeholder values are demonstrated in README examples. These patterns risk accidental promotion of development secrets or reuse of weak defaults in production. The issue is thus not plaintext password storage in the database, but exposure and handling of operational secrets and a hard-coded default credential pattern.

	\textbf{CWE Explanation}: CWE-256 covers storing credentials without adequate protection (encryption, hashing, vault-based segregation) or exposing them in source artifacts (scripts, config files, comments) such that compromise of the repository or workstation yields immediate credential disclosure. It overlaps with CWE-798 (hard-coded credentials) when defaults are embedded, and with CWE-522 when credential protection mechanisms are insufficient.

	\textbf{Severity}: Medium (would escalate toward High if the disclosed admin password or example secrets were deployed unchanged beyond local development).

\subsection*{Vulnerability Locations and Type}
\begin{itemize}
		\item \textbf{Seed script comment}: \texttt{scripts/create-admin-user.sql} contains a cleartext default admin password in a comment (hard-coded / discoverable credential pattern).
		\item \textbf{Environment variables}: \texttt{.env} (excluded from VCS, but encouraged) stores DB root/user passwords and truststore password in plaintext. Acceptable locally, but no segregation or rotation policy specified for higher environments.
		\item \textbf{Truststore password exposure}: Passed directly via \texttt{SPRING\_DATASOURCE\_HIKARI\_TRUSTSTORE\_PASSWORD} environment variable; resident in process environment and potentially logs if misconfigured.
		\item \textbf{Placeholder weak values}: README examples (\texttt{rootpassword}, \texttt{appuserpassword}, \texttt{truststorepassword}) risk being reused verbatim.
	\item \textbf{No secret scanning / policy}: CI/CD pipeline (not documented) lacks automated detection to block accidental secret commits.
\end{itemize}

\subsection*{Mitigation Strategy and Rationale}
Focus on eliminating static/discoverable secrets in source and strengthening operational handling: (1) remove or parameterise default credentials; (2) introduce secret generation at setup time with one-time display; (3) adopt a secrets manager for non-local deployments; (4) enforce least-privilege DB accounts (separate admin vs app user); (5) integrate automated secret scanning to prevent regressions; (6) clearly label placeholder values as `CHANGEME` to discourage reuse. This reduces credential exposure surface and shortens compromise window via rotation and principle of least privilege.

\subsection*{Implemented / Planned Security Controls}
\begin{enumerate}
	\item \textbf{Password hashing (implemented)}: All end-user passwords stored using BCrypt (adaptive, salted) eliminating plaintext password-at-rest risk.
	\item \textbf{DTO redaction (implemented)}: Password hashes no longer returned by any API endpoints, reducing secondary leakage channels.
	\item \textbf{Encrypted DB transport (implemented)}: Mitigates interception of database credentials post-auth handshake.
	\item \textbf{Remove default admin secret (planned)}: Replace hard-coded admin credential comment with instruction to supply a strong password (or script-driven random generation).
	\item \textbf{Secret generation (planned)}: Modify setup scripts to auto-generate strong random passwords (e.g. 24+ char base64) and print once.
	\item \textbf{Secrets manager integration (planned)}: Externalise production secrets (Vault / cloud provider store) removing reliance on persistent `.env` in production.
	\item \textbf{Least privilege DB accounts (planned)}: Separate schema migration/admin from runtime application user; restrict privileges to required CRUD.
	\item \textbf{Secret scanning in CI (planned)}: Add tools (e.g. Gitleaks / TruffleHog) to detect accidental commits of secrets or weak defaults.
		\item \textbf{Documentation hardening (planned)}: Mark all sample credentials as \texttt{CHANGEME\_<PURPOSE>} to prevent reuse in non-local deployments.
\end{enumerate}

\subsection*{Solution Effectiveness}
\begin{itemize}
	\item Existing hashing already neutralises the most severe impact vector (direct theft of user passwords from DB).
	\item Removing the disclosed admin password and auto-generating credentials eliminates a trivial, high-impact compromise path.
	\item Secrets manager + least privilege narrows lateral movement after host compromise: stolen app credential yields only scoped DB access.
	\item CI secret scanning provides early detection and prevents regression (shift-left control).
	\item Clear CHANGEME placeholders reduce likelihood of weak default propagation to production.
\end{itemize}

\chapter{A03:2021 Injection}


\section{CWE-89: SQL Injection}

	\textbf{Description}: Assessment of the BookShop application's data-access layer found no exploitable SQL Injection vectors in its current state. All persistence operations are performed through Spring Data JPA repository interfaces using method-name derived queries (e.g. \texttt{findByUsername}) or inherited CRUD methods. There is no evidence of string concatenation to build JPQL/SQL, no usage of \texttt{@Query} with interpolated parameters, and no raw JDBC / native query execution paths. Consequently, untrusted user input is never directly merged into executable SQL without parameter binding.

	\textbf{CWE Explanation}: CWE-89 (SQL Injection) arises when an application constructs SQL statements by directly embedding untrusted input, allowing attackers to alter query structure (e.g. changing WHERE clauses, UNION extraction, or triggering stacked queries in permissive drivers). Proper parameterisation ensures user data is treated strictly as values, not executable syntax.

	\textbf{Severity}: None (Not Vulnerable) at present. Would elevate rapidly to High if future features introduce unparameterised dynamic queries.


\subsection*{Assessment Evidence}
Audit activities and findings:
\begin{itemize}
 \item Grep searches for raw SQL construction indicators returned no matches: patterns \texttt{createNativeQuery}, \texttt{@Query}, \texttt{PreparedStatement}, \texttt{Statement}, direct SQL keywords (SELECT/INSERT/UPDATE/DELETE) absent from code except in comments.
 \item No repository methods annotated with \texttt{@Query}; only Spring Data derived query methods (e.g. \texttt{findByUsername}) which use prepared parameter binding under the hood.
 \item No usage of \texttt{EntityManager}, \texttt{JdbcTemplate}, Criteria API, or manual pagination/sorting parameters that could introduce unsafe field injection.
 \item No dynamic ORDER BY / filtering logic sourced from request parameters (no \texttt{Sort} / \texttt{Pageable} occurrences) that could later encourage string concatenation.
 \item Domain entities contain only mapped fields; user-supplied values become parameters in prepared statements generated by the JPA provider (Hibernate), not concatenated SQL fragments.
\end{itemize}


\subsection*{Mitigation Strategy and Rationale}
Maintain a \textit{parameterisation-only} data access pattern and introduce guardrails so future changes cannot silently introduce injection risk. Emphasise: (1) exclusive use of Spring Data method derivation or \texttt{@Query} with named / positional parameters, (2) strict white-listing of sortable / filterable fields when adding dynamic search endpoints, and (3) code review / CI rules to flag raw SQL introduction.

\subsection*{Implemented / Planned Controls}
\begin{enumerate}
 \item \textbf{Spring Data repositories (implemented)}: Auto-generated prepared statements ensure parameter binding.
 \item \textbf{No raw SQL / native queries (implemented)}: Eliminates primary injection surface.
 \item \textbf{Input validation (partial)}: Bean validation (@NotBlank) constrains some inputs; while not a primary defence for injection, it reduces anomalous payload shapes.
 \item \textbf{Repository pattern adherence (planned guardrail)}: Architectural decision record (ADR) to codify prohibition of ad hoc JDBC unless justified with security review.
 \item \textbf{Static scan rule (planned)}: CI grep / SAST rule to flag introduction of \texttt{@Query("\%" + var)} style concatenations or \texttt{createNativeQuery}.
 \item \textbf{Dynamic sort/filter sanitisation (planned)}: If future endpoints accept field names, implement white-list mapping (enum -> column) to avoid direct trust in request parameters.
 \item \textbf{Security review checklist (planned)}: Mandatory review item for any PR adding raw SQL, native queries, or criteria builder logic.
\end{enumerate}


\subsection*{Solution Effectiveness}
\begin{itemize}
 \item Absence of raw or annotated custom queries removes typical injection entry points.
 \item Hibernate's prepared statement generation enforces separation of code and data, neutralising payloads containing quotes or control tokens.
 \item Planned guardrails reduce regression risk as feature scope expands (search, reporting, analytics).
 \item White-list driven future dynamic sorting/filtering prevents second-order injection through column / direction parameters.
\end{itemize}


\section{CWE-20: Improper Input Validation}

	\textbf{Description}: The application previously accepted numerous user-controlled inputs (registration data, cart item quantities, book metadata, author names, payment form field) without comprehensive server-side validation. Only sparse annotations (e.g. \texttt{NotBlank}) existed on a subset of entity fields and were inconsistently enforced (many controller endpoints lacked \texttt{Valid}). This gap allowed malformed, extreme, or semantically invalid values (negative or enormous quantities, impossible years, invalid ISBNs, oversized strings) to reach persistence and business logic layers, risking data integrity degradation, logic manipulation, and denial-of-service via oversized payloads. Recent changes introduced structured DTOs and Bean Validation constraints to close these vectors.

	\textbf{CWE Explanation}: CWE-20 (Improper Input Validation) arises when an application fails to define and enforce syntactic, semantic, or range constraints on externally supplied data before use. Inadequate validation can cascade into numerous secondary weaknesses (injection, overflow, business rule abuse) by allowing maliciously crafted input to impact data stores, processing logic, or downstream APIs.

	\textbf{Severity}: Medium (Residual Low after implemented controls)  Core validation now present; remaining exposure relates to legacy MVC form bindings and unvalidated optional fields slated for refactor.

\subsection*{Vulnerability Locations and Type}
\begin{itemize}
	\item \textbf{Entity direct binding}: Controllers bound domain entities (e.g. \texttt{Customer}, \texttt{Book}) directly from request bodies or form submissions, inheriting every writable field without a whitelist.
	\item \textbf{Missing range/format constraints}: No length or pattern enforcement for ISBN, phone numbers, names, addresses; numeric fields permitted negative or extreme values (price, quantity, year, numberOfCopies).
	\item \textbf{Quantity manipulation}: Cart add-item accepted arbitrary (including zero/negative) quantities enabling inventory or pricing anomalies.
	\item \textbf{Payment form}: Credit card number field had no format, length, or checksum validation (and is non-functional demo data).
	\item \textbf{Silent extra fields}: Jackson deserialization accepted unknown JSON properties (risk of future mass assignment if sensitive setters are added).
\end{itemize}

\subsection*{Mitigation Strategy and Rationale}
Adopt a defence-in-depth input sanitation model: (1) Introduce dedicated request DTOs with explicit whitelists and Bean Validation annotations; (2) Apply semantic, syntactic, and range constraints (regex, size, numeric bounds); (3) Enforce validation by annotating controller method parameters with \texttt{@Valid}; (4) Fail fast with a consistent error contract via a global exception handler; (5) Harden deserialization to reject unknown properties, preventing accidental acceptance of stray or future-sensitive fields. This systematic approach ensures only well-formed, business-compliant data continues beyond the controller boundary.


\subsection*{Implemented Security Controls}
\begin{enumerate}
	\item \textbf{CustomerRegistrationDto  Bean Validation}: Username, password, personal and contact fields now constrained with length, pattern, and format annotations (e.g. \texttt{Email}, phone regex) and enforced through \texttt{Valid}.
	\item \textbf{Book field constraints}: Added size, ISBN pattern (ISBN-10/13), year range (1450â€“2100), non-negative price with scale check, and bounded copy counts.
	\item \textbf{Cart add-item validation}: Quantity now requires minimum 1 (\texttt{Min(1)}), preventing negative or zero-impact manipulations.
	\item \textbf{Global validation handler}: Central \texttt{ControllerAdvice} standardises 400 responses and prevents verbose default error leakage.
	\item \textbf{Strict deserialization}: \texttt{spring.jackson.deserialization.fail-on-unknown-properties true} rejects payload fields not explicitly declared in DTOs, blocking silent mass-assignment style expansion.
	\item \textbf{Password hashing continuity}: Ensures even validated credential inputs are irreversibly stored (complements validation by preserving confidentiality).
	\item \textbf{Field renaming hygiene}: Normalised \texttt{bookName} naming to prevent tooling / lint confusion and encourage consistent property-level validation.
\end{enumerate}


\subsection*{Planned / Remaining Controls}
\begin{itemize}
	\item Introduce DTOs and validation for MVC Book/Author form submissions to replace direct entity binding.
	\item Add validation (or removal) of the demo credit card field with checksum (Luhn) if retained.
	\item Enforce maximum aggregate payload sizes at reverse proxy and apply additional per-field size caps where user-generated text is later introduced.
	\item Add rate limiting (ties to CWE-799) to reduce brute-force probing of validation boundaries.
	\item Add automated tests asserting rejection of malformed ISBNs, negative quantities, overlong fields.
	\item Implement business rule validators (e.g. inventory non-negative after operations) as custom constraints or service assertions.
\end{itemize}


\subsection*{Solution Effectiveness}
\begin{itemize}
	\item \textbf{Whitelisting DTOs}: Replaces broad entity binding with curated inputs, eliminating inadvertent exposure of internal or future sensitive fields (prevents mass assignment class of CWE-20 derived issues).
	\item \textbf{Bean Validation enforcement}: Declarative constraints ensure malformed data is rejected pre-persistence, safeguarding data integrity and reducing attack surface for logic abuse or cascading injection vectors.
	\item \textbf{Semantic constraints}: ISBN regex, numeric bounds, and size limits prevent structurally invalid data that could otherwise fuel business logic anomalies or storage bloat.
	\item \textbf{Fail-fast error handling}: Consistent 400 responses shrink observability for attackers attempting boundary probing (no stack traces or partial processing side-effects).
	\item \textbf{Unknown property rejection}: Blocks introduction of rogue fields trying to smuggle unexpected values, a common foothold for privilege inflation or latent injection when new setters appear.
	\item \textbf{Quantity constraints}: Prevent negative or zero manipulations that could be leveraged to produce free/credit scenarios or integer underflow in future calculations.
	\item \textbf{Normalization \& naming hygiene}: Clear, conventional field naming supports static analysis and future automated policy checks, reducing misconfiguration risk.
\end{itemize}


\section{CWE-79: Cross-Site Scripting (XSS)}

	\textbf{Description}: A structured audit of all server-rendered HTML (Thymeleaf templates under \texttt{src/main/resources/templates}) and relevant controller pathways found \textit{no exploitable Cross-Site Scripting vectors} in the current codebase. All user-controlled fields are emitted via Thymeleaf's escaped expression and form binding mechanisms (e.g. \texttt{th:text}, \texttt{th:field}, attribute processors) which HTML-encode special characters. There is \textbf{no} use of unescaped output primitives (\texttt{th:utext}), inlined JavaScript expression substitutions (\texttt{[[...]]} / \texttt{[(...)]}), or manual string concatenation inserting raw request data into script blocks or event handler attributes. Earlier template refactors (e.g. renaming to \texttt{bookName}) maintained escaped bindings and removed any need for ad hoc unescaped placeholders. Consequently attacker-supplied input cannot break containment to execute script in another user's browser under current functionality.

	\textbf{CWE Explanation}: CWE-79 arises when untrusted input is included in a web page without proper context-aware encoding or sanitisation, enabling the injection and execution of arbitrary script in the victim's browser (reflected, stored, or DOM-based). Preventing XSS requires systematically neutralising user-controlled characters significant to HTML/JS parsing or restricting script execution pathways.

	\textbf{Severity}: None (Not Vulnerable at present). Would elevate if future rich text / HTML features or unescaped rendering are introduced without sanitisation.

\subsection*{Assessment Evidence}
Audit activities and supporting findings:
\begin{itemize}
 \item Grep searches for unescaped constructs returned none: patterns \texttt{th:utext} and inline substitution delimiters \texttt{[[} / \texttt{[(} (used for inlined JS) are absent.
 \item No occurrences of raw output methods or manual HTML string assembly in controllers/services; all views resolved through Thymeleaf templates.
 \item All dynamic textual content rendered with escaping processors (\texttt{th:text}, \texttt{th:value}, \texttt{th:field}); no direct usage of \texttt{th:utext} (which would bypass encoding).
 \item No template inlined JavaScript blocks containing template expressions; only static script includes are present.
 \item No reflection of request parameters into error pages or query string echoes; validation errors are summarised as plain escaped messages via the global handler.
 \item Input validation (length/pattern constraints) reduces payload surface even if an encoding bypass were later introduced.
 \item Template field rename adjustments (\texttt{book\_name} -> \texttt{bookName}) avoided broken bindings that might otherwise tempt unescaped insertions.
\end{itemize}

\subsection*{Mitigation Strategy and Rationale}
Maintain a \textit{strict auto-escape} posture while adding forward-looking guardrails: (1) rely solely on Thymeleaf's escaped output features for plain text; (2) introduce Content Security Policy (CSP) to constrain script execution sources; (3) forbid unescaped directives (\texttt{th:utext}) except under explicit security review with server-side sanitisation; (4) implement lint / CI checks for introduction of risky constructs; (5) if future rich text/user HTML is required, apply a conservative allow-list sanitizer before persistence and still encode on output.

\subsection*{Implemented / Planned Controls}
\begin{enumerate}
 \item \textbf{Escaped template rendering (implemented)}: Exclusive use of \texttt{th:text}, \texttt{th:field}, and attribute processors ensures HTML entity encoding.
 \item \textbf{Absence of unescaped primitives (implemented)}: No \texttt{th:utext} or inline expression substitutions eliminates common bypass channels.
 \item \textbf{No dynamic script construction (implemented)}: No server-sourced data injected into inline \texttt{<script>} blocks or event handler attributes.
 \item \textbf{Input validation (implemented)}: Bean Validation narrows malicious payload shapes (defence-in-depth only).
 \item \textbf{CSP header (planned)}: Add restrictive \texttt{Content-Security-Policy} (e.g. \texttt{script-src 'self'; object-src 'none'; base-uri 'self'; frame-ancestors 'none'}) to mitigate impact if an injection slips through.
 \item \textbf{Template guardrail (planned)}: CI rule / review checklist to flag additions of \texttt{th:utext}, inline script expressions, or event attributes containing untrusted expressions.
 \item \textbf{Rich text sanitisation policy (planned)}: If future features require formatted user content, adopt an allow-list HTML sanitizer (e.g. OWASP Java HTML Sanitizer) prior to storage.
 \item \textbf{Security headers bundle (planned)}: Referrer-Policy, Permissions-Policy, and strengthening cookies (Secure, HttpOnly, SameSite) to reduce session theft avenues in case of future XSS.
\end{enumerate}

\subsection*{Solution Effectiveness}
\begin{itemize}
 \item Auto-escaping neutralises script meta-characters (<, >, \&, quotes) preventing payload interpretation as active markup.
 \item Lack of unescaped or inline script sinks removes primary exploit vectors (no DOM insertion points for attacker data).
 \item Planned CSP provides a containment layer limiting execution even if an HTML injection is discovered later (e.g. blocks external script exfiltration).
 \item Guardrail automation (grep / CI checks) lowers regression risk as templates evolve.
 \item Sanitisation policy planning ensures future feature expansion (rich text) introduces structured controls rather than ad hoc exceptions.
\end{itemize}



\chapter{A04:2021 Insecure Design}


\section{CWE-307: Improper Restriction of Excessive Authentication Attempts}

	\textbf{Description}: The application originally permitted unlimited rapid authentication attempts against the \texttt{/login} endpoint with no per-username or per-IP throttling, enabling brute force, credential stuffing, and password spraying attacks. Attackers could iterate common or leaked credential pairs without delay, increasing account takeover likelihood and aiding enumeration of valid usernames through timing/lockout observation (although failure messages were uniform). This condition constitutes CWE-307 prior to recently implemented controls.

	\textbf{CWE Explanation}: CWE-307 arises when an application fails to enforce limits on repeated authentication attempts (e.g. password, MFA, reset token submissions), allowing automated high-frequency guessing that can compromise accounts or facilitate credential stuffing campaigns. Proper controls (lockout, backoff, rate limiting) reduce the feasible attempt rate and raise detection opportunities.

	\textbf{Severity}: Low (Residual) â€” Core throttling and lockout controls now implemented; remaining exposure is limited to single-instance memory scope and absence of distributed correlation.

\subsection*{Vulnerability Locations and Type}
\begin{itemize}
	\item \textbf{Login endpoint}: POST \texttt{/login} accepted unlimited sequential failures (no max attempt threshold, delay, or CAPTCHA escalation).
	\item \textbf{Lack of per-identity lockout}: No temporary suspension after repeated incorrect credentials for the same username.
	\item \textbf{Lack of IP spray detection}: No broader rate control for an IP submitting many different usernames (credential stuffing pattern).
	\item \textbf{Absence of central attempt telemetry}: No counters or logs dedicated to failed authentication bursts (reduced detection / alerting capability).
\end{itemize}

\subsection*{Mitigation Strategy and Rationale}
Adopt a layered throttling model combining \textit{pre-auth rejection} (cheap filter), \textit{account/IP scoped lockout}, and \textit{reset on success}: (1) Intercept login requests prior to authentication to block already locked principals (resource preservation); (2) Maintain rolling failure windows and impose temporary locks (discourages brute force); (3) Track both username and source IP to differentiate targeted vs spray attacks; (4) Provide generic error responses to avoid username enumeration; (5) Reset counters on successful authentication to reduce accidental lockouts and user friction. This approach sharply lowers feasible guessing throughput while keeping implementation lightweight.

\subsection*{Implemented / Planned Security Controls}
\begin{enumerate}
	\item \textbf{Failure counting service (implemented)}: \texttt{LoginAttemptService} tracks failures per username (threshold 5 in 15 min) and per IP (threshold 30) and enforces a 10 minute lock via timestamp comparison.
	\item \textbf{Pre-auth rate limiting filter (implemented)}: \texttt{LoginRateLimitingFilter} short-circuits POST \texttt{/login} when a username or IP is locked, returning HTTP 429 (Too Many Requests) without invoking downstream authentication logic.
	\item \textbf{Success / failure handlers (implemented)}: \texttt{AuthenticationHandlers} records failures and clears username attempts upon success, limiting persistent false positives.
	\item \textbf{Uniform error messaging (existing)}: Generic \texttt{/login?error} response avoids disclosing whether the username or password was invalid, reducing enumeration signal.
	\item \textbf{Session fixation protection (existing)}: Complements throttling by ensuring hijacked pre-auth sessions cannot be leveraged mid-brute force.
	\item \textbf{Planned distributed store (planned)}: Externalise counters to Redis or similar for horizontal scaling and shared lock state across instances.
	\item \textbf{Planned anomaly alerting (planned)}: Emit structured security log events (e.g. JSON) for failed attempt spikes to feed SIEM alert rules.
	\item \textbf{Optional adaptive challenges (planned)}: Introduce CAPTCHA or MFA step-up after multiple failures to add friction for automation.
\end{enumerate}

\subsection*{Solution Effectiveness}
\begin{itemize}
	\item \textbf{Throughput reduction}: Lock + 429 response immediately halts further processing after threshold, capping guess attempts per window.
	\item \textbf{Spray mitigation}: Separate IP threshold limits credential stuffing patterns distributing attempts across many usernames.
	\item \textbf{Low overhead}: Early filter rejection conserves CPU and avoids unnecessary password hash comparisons under attack.
	\item \textbf{Reset on success}: Minimises legitimate user friction (no long-lived stale counters) while preserving deterrence for attackers.
	\item \textbf{Scalability path}: Planned move to distributed cache preserves semantics in multi-node deployment, preventing bypass via node cycling.
	\item \textbf{Extensibility}: Architecture supports extension to MFA attempt throttling or account recovery flows using same service abstraction.
\end{itemize}

Current posture: \textit{Not vulnerable in current single-instance context}. Residual risk relates to lack of distributed correlation and absence of automated alerting â€” both scheduled for future enhancement.


\section{CWE-654: Reliance on a Single Security Mechanism}

	\textbf{Description}: Earlier application iterations exhibited several controls implemented as a \textit{single protective layer} (e.g. relying only on URL pattern role checks without ownership validation, only template auto-escaping without complementary Content Security Policy, only password length without strength criteria, only a brute-force threshold without password complexity). Such single points of failure meant a bypass or misconfiguration of that one mechanism could fully expose the protected asset class (authorization, session integrity, input handling). Recent changes introduced layered, mutually reinforcing safeguards reducing the likelihood that a single defect reopens critical exploit paths.

	\textbf{CWE Explanation}: CWE-654 (Reliance on a Single Security Mechanism) occurs when security depends exclusively on one control whose failure (design flaw, misconfiguration, regression) leads directly to compromise. Defence-in-depth requires stacking independent, diverse mechanisms so that breaking one does not immediately yield the target outcome.

	\textbf{Severity}: Low (Residual) â€” Core high-impact areas (authentication, authorization, input handling, XSS prevention) now have multiple layers; remaining items are enhancement opportunities (e.g. MFA, distributed rate limiting, security event monitoring).

\subsection*{Former Single-Layer Examples}
\begin{itemize}
	\item \textbf{Authorization}: Initially only antMatcher path rules; missing method-level and ownership checks (fixed via @PreAuthorize + per-resource ownership validation).
	\item \textbf{User registration validation}: Relied solely on basic length checks (no central strength or uniqueness service); now augmented with regex-based complexity + duplicate detection service reused by API and MVC.
	\item \textbf{XSS prevention}: Depended only on Thymeleaf escaping; CSP and restrictive security headers now add containment.
	\item \textbf{Brute force defence}: Absent (unlimited attempts) then singular (lockout only); now combined with per-username/IP counters + strong password policy (different control classes).
	\item \textbf{Session confidentiality}: Previously dependent only on password hashing and implicit session rotation; now complemented by cookie flags (Secure/HttpOnly/SameSite) and planned TLS enforcement + HSTS (prod).
\end{itemize}

\subsection*{Mitigation Strategy and Rationale}
Refactor high-risk pathways to adopt \textit{layered, heterogeneous controls}: (1) combine coarse-grained (path) and fine-grained (method + ownership) authorization; (2) pair input auto-escaping with CSP to constrain script execution; (3) augment brute-force rate limiting with credential quality requirements; (4) segregate validation logic into a shared service to prevent bypass via alternative controller flows; (5) harden session tokens with transport + cookie attributes rather than relying solely on secrecy; (6) plan observability (logging/alerting) to detect failures when controls degrade.

\subsection*{Implemented / Planned Controls}
\begin{enumerate}
	\item \textbf{Authorization layering (implemented)}: Path matcher + @PreAuthorize + ownership checks (customers, carts) reduce single failure risk.
	\item \textbf{Central registration validation (implemented)}: Shared \texttt{RegistrationValidationService} ensures password strength and uniqueness on both API and MVC paths.
		\item \textbf{Password complexity (implemented)}: Regex enforces multi-class, length $\ge 12$; complements throttle logic.
	\item \textbf{Brute force throttling (implemented)}: Username/IP attempt tracking + lockout independent of password policy.
	\item \textbf{CSP + security headers (implemented)}: CSP, Referrer-Policy, Permissions-Policy, frame denial, content type options reduce reliance on template escaping.
	\item \textbf{Cookie hardening (implemented)}: Secure, HttpOnly, SameSite=Strict flags add transport and CSRF resilience around session identifier.
	\item \textbf{Session fixation mitigation (implemented)}: Explicit session migration adds session integrity to cookie/transport protections.
\end{enumerate}

\subsection*{Solution Effectiveness}
\begin{itemize}
	\item \textbf{Multiple independent checks}: Compromise now requires defeating distinct classes (e.g. both path matcher and ownership, or escaping and CSP).
	\item \textbf{Regressive change resilience}: A misconfigured path rule no longer exposes data absent simultaneous method/ownership regression.
	\item \textbf{Reduced credential attack ROI}: Attackers must overcome both throttling and stronger passwords, lowering feasible success probability per unit time.
	\item \textbf{Containment of injection attempts}: Even if raw HTML were introduced inadvertently, CSP constrains script execution sources.
	\item \textbf{Consistent validation reuse}: Central service prevents alternate controller paths from silently bypassing strength/uniqueness checks.
	\item \textbf{Future scalability path}: Planned distributed counters and MFA further decrease single-point reliance as deployment complexity grows.
\end{itemize}


\chapter{A05:2021 Security Misconfiguration}


\section{CWE-250: Execution with Unnecessary Privileges}

\textbf{Description}: The BookShop application's containerized deployment originally executed the Java application process as the root user within the Docker container, providing unnecessary administrative privileges that could be exploited in case of application compromise. The base \texttt{openjdk:17-jdk-slim} image defaults to root execution, and the Dockerfile lacked explicit privilege dropping or non-root user creation. This elevated privilege context increases the potential blast radius of any remote code execution, container escape, or file system manipulation attacks targeting the application runtime.

\textbf{CWE Explanation}: CWE-250 (Execution with Unnecessary Privileges) occurs when a program runs with more privileges than required for its intended functionality, enabling attackers who compromise the application to leverage those excess rights for privilege escalation, system manipulation, or lateral movement that would otherwise be prevented by proper isolation.

\textbf{Severity}: Medium (Residual Low after implemented controls) â€” Core runtime now uses non-root user; remaining exposure relates to container orchestration hardening and potential shared kernel vulnerabilities.

\subsection*{Vulnerability Locations and Type}
\begin{itemize}
  \item \textbf{Container root execution}: Dockerfile lacked \texttt{USER} directive, causing Java process to inherit root privileges from base image.
  \item \textbf{Filesystem write permissions}: Root ownership of application directory enabled arbitrary file creation/modification by compromised process.
  \item \textbf{Broad container capabilities}: Default Docker capabilities (though restricted compared to host root) still provided unnecessary network, process, and system manipulation abilities.
  \item \textbf{No privilege boundaries}: Absence of read-only filesystem or capability dropping meant successful exploitation could modify container state persistently.
\end{itemize}

\subsection*{Mitigation Strategy and Rationale}
Implement \textit{principle of least privilege} at container level: (1) Create dedicated non-root user for application execution; (2) Set proper file ownership and restrict write access to necessary directories only; (3) Use read-only root filesystem with limited writable mounts; (4) Drop unnecessary Linux capabilities and prevent privilege escalation; (5) Apply security contexts that enforce non-root execution and prevent capability acquisition. This approach ensures that even if the Java application is compromised, the attacker gains minimal system access.

\subsection*{Implemented / Planned Security Controls}
\begin{enumerate}
  \item \textbf{Non-root user creation (implemented)}: Added \texttt{app} system user and group in Dockerfile with restricted shell access.
  \item \textbf{File ownership transfer (implemented)}: Set \texttt{chown -R app:app /app} to ensure application files owned by non-privileged user.
  \item \textbf{USER directive (implemented)}: Explicit \texttt{USER app} instruction prevents root process execution.
  \item \textbf{Read-only filesystem (planned)}: Docker Compose \texttt{read\_only: true} with \texttt{tmpfs} for writable areas.
  \item \textbf{Capability dropping (planned)}: \texttt{cap\_drop: ALL} and selective \texttt{cap\_add} for required network binding only.
  \item \textbf{Security options (planned)}: \texttt{no-new-privileges:true} prevents runtime privilege escalation attempts.
  \item \textbf{Minimal base image (planned)}: Evaluate migration to distroless or Alpine-based images for reduced attack surface.
  \item \textbf{Runtime privilege validation (planned)}: Application startup check refusing to run as root user.
\end{enumerate}

\subsection*{Solution Effectiveness}
\begin{itemize}
  \item \textbf{Privilege containment}: Non-root execution limits file system manipulation to application-owned directories and prevents system-level modifications.
  \item \textbf{Reduced exploit impact}: Compromise of Java process no longer yields container administrative access or ability to modify critical system files.
  \item \textbf{Defense against container escape}: Limited capabilities and non-root context reduce effectiveness of kernel vulnerability exploitation.
  \item \textbf{Compliance alignment}: Follows container security best practices (CIS Docker Benchmark) for production deployment.
  \item \textbf{Forensic clarity}: Non-root execution provides cleaner audit trails distinguishing application activity from system operations.
\end{itemize}


\section{CWE-693: Protection Mechanism Failure}

\textbf{Description}: The BookShop application originally suffered from a critical protection mechanism failure where CSRF (Cross-Site Request Forgery) protection was deliberately disabled in the security configuration, creating a single point of failure that undermined the effectiveness of other security controls. The disabled CSRF protection exposed all state-changing operations to cross-site request forgery attacks, allowing malicious websites to perform unauthorized actions on behalf of authenticated users. This represented a classic example of protection mechanism failure where a fundamental security control was intentionally disabled, creating vulnerability despite other defensive measures being in place.

\textbf{CWE Explanation}: CWE-693 (Protection Mechanism Failure) occurs when a protection mechanism fails to provide adequate security for the system, often due to disabled security controls, single points of failure, or inadequate implementation of security mechanisms that other controls depend upon for their effectiveness.

\textbf{Severity}: High (Resolved) â€” Critical protection mechanism failure eliminated; defense-in-depth now properly implemented with multiple overlapping security layers.

\subsection*{Vulnerability Locations and Type}
\begin{itemize}
	\item \textbf{Disabled CSRF protection}: SecurityConfig explicitly disabled CSRF with \texttt{.csrf(AbstractHttpConfigurer::disable)} creating a single point of failure in protection mechanisms.
	\item \textbf{Missing CSRF tokens}: All state-changing forms (login, registration, cart operations, admin functions) lacked CSRF token validation.
	\item \textbf{Inadequate cross-origin controls}: No CORS configuration to prevent unintended cross-origin requests in API endpoints.
	\item \textbf{Single-layer dependencies}: Other security mechanisms (authentication, authorization, session management) depended on request authenticity that CSRF protection should have provided.
\end{itemize}

\subsection*{Mitigation Strategy and Rationale}
Implement \textit{defense-in-depth with no single points of failure}: (1) Re-enable CSRF protection with proper token handling across all forms; (2) Add CSRF tokens to all state-changing operations while maintaining API flexibility; (3) Implement proper origin validation for cross-origin requests; (4) Ensure multiple overlapping security controls protect critical operations; (5) Validate that security mechanisms complement rather than replace each other. This approach ensures that compromise of any single protection mechanism does not fully expose the application to attack.

\subsection*{Implemented / Planned Security Controls}
\begin{enumerate}
	\item \textbf{CSRF protection re-enabled (implemented)}: Modified SecurityConfig to enable CSRF protection with selective exclusion for API endpoints (\texttt{/api/**}).
	\item \textbf{CSRF token integration (implemented)}: Added \texttt{<input type="hidden" th:name="\${\_csrf.parameterName}" th:value="\${\_csrf.token}"/>} to all state-changing forms.
	\item \textbf{Comprehensive form coverage (implemented)}: Applied CSRF tokens to login, registration, cart operations, book management, author management, and logout forms.
	\item \textbf{Origin validation (implemented)}: Restrictive approach avoiding overly permissive CORS configuration that could reintroduce vulnerabilities.
	\item \textbf{Layered authorization (existing)}: Path-based + method-level + ownership checks provide multiple authentication/authorization layers.
	\item \textbf{Session security hardening (existing)}: Secure/HttpOnly/SameSite cookie attributes + session fixation protection complement CSRF protection.
	\item \textbf{Input validation layers (existing)}: Bean validation + central password policy + rate limiting provide additional protective layers.
	\item \textbf{Security headers defense (existing)}: CSP, Referrer-Policy, Permissions-Policy provide browser-level protection complementing server-side controls.
\end{enumerate}

\subsection*{Solution Effectiveness}
\begin{itemize}
	\item \textbf{Eliminates single point of failure}: CSRF protection no longer represents a disabled critical control that other mechanisms depend upon.
	\item \textbf{Cross-site attack prevention}: All state-changing operations now protected against cross-site request forgery attempts.
	\item \textbf{Defense-in-depth validation}: Multiple overlapping security controls ensure that failure of one layer does not compromise overall security.
	\item \textbf{Request authenticity assurance}: CSRF tokens ensure that state-changing requests originate from legitimate user interactions within the application.
	\item \textbf{Maintains API flexibility}: Selective CSRF exclusion for API endpoints preserves stateless authentication capabilities while protecting web forms.
	\item \textbf{Production-ready posture}: All critical protection mechanisms now enabled and properly configured for production deployment.
\end{itemize}


\section{CWE-1021: Improper Restriction of Rendered UI Layers or Frames}

\textbf{Description}: The BookShop application is NOT vulnerable to CWE-1021 (Improper Restriction of Rendered UI Layers/Frames). The application implements robust frame protection mechanisms through multiple defensive layers including both legacy and modern browser security controls. Analysis confirms comprehensive protection against clickjacking attacks through proper configuration of frame restriction headers and absence of vulnerable frame elements in the user interface.

\textbf{CWE Explanation}: CWE-1021 (also known as Clickjacking) occurs when an application can be embedded in frames or iframes by malicious websites, allowing attackers to trick users into clicking on hidden or disguised elements. This enables unauthorized actions by overlaying the legitimate application interface with deceptive content.

\textbf{Severity}: None (Not Vulnerable) â€” Comprehensive frame protection implemented with defense-in-depth approach using multiple overlapping security controls.

\subsection{Security Assessment Evidence}
The application demonstrates proper protection through multiple mechanisms:
\begin{itemize}
	\item \textbf{X-Frame-Options header}: Server responds with \texttt{X-Frame-Options: DENY}, completely preventing frame embedding from any origin.
	\item \textbf{Content Security Policy}: CSP directive \texttt{frame-ancestors 'none'} provides modern browser protection against frame embedding.
	\item \textbf{Template security}: Audit of all HTML templates confirms no vulnerable \texttt{<iframe>}, \texttt{<frame>}, or \texttt{<embed>} elements that could be exploited.
	\item \textbf{Consistent enforcement}: Frame protection applies to all application endpoints without exceptions.
\end{itemize}

\subsection{Implementation Details}
Security configuration in \texttt{SecurityConfig.java} explicitly implements frame protection:
\begin{itemize}
	\item \textbf{Frame options configuration}: \texttt{.frameOptions(fo -> fo.deny())} sets the most restrictive frame policy.
	\item \textbf{CSP integration}: Content Security Policy includes \texttt{frame-ancestors 'none'} directive for modern browser compatibility.
	\item \textbf{Defense-in-depth}: Multiple protection layers ensure comprehensive coverage across different browser capabilities.
\end{itemize}

\subsection{Protection Strategy and Rationale}
The application follows security best practices by implementing a \textit{deny-by-default} frame policy with multiple enforcement mechanisms: (1) Legacy browser support through X-Frame-Options DENY header; (2) Modern browser protection via CSP frame-ancestors directive; (3) Template-level security ensuring no self-framing vulnerabilities; (4) Consistent policy application across all endpoints. This layered approach ensures protection even if individual mechanisms fail or are bypassed.

\subsection{Implemented Security Controls}
\begin{enumerate}
	\item \textbf{X-Frame-Options: DENY (implemented)}: Most restrictive frame option preventing embedding from any source, including same-origin.
	\item \textbf{CSP frame-ancestors 'none' (implemented)}: Modern Content Security Policy directive providing equivalent protection with better browser support.
	\item \textbf{Template audit verification (implemented)}: Confirmed absence of problematic frame elements that could create self-framing vulnerabilities.
	\item \textbf{Comprehensive header suite (implemented)}: Frame protection integrated with other security headers (CSP, Referrer-Policy, Permissions-Policy) for holistic defense.
\end{enumerate}

\subsection{Protection Effectiveness}
\begin{itemize}
	\item \textbf{Complete frame prevention}: DENY policy blocks all frame embedding attempts, eliminating clickjacking attack surface entirely.
	\item \textbf{Browser compatibility}: Dual header approach (X-Frame-Options + CSP) ensures protection across both legacy and modern browsers.
	\item \textbf{No bypass vectors}: Absence of frame elements in templates prevents self-framing or legitimate embedding that could be hijacked.
	\item \textbf{Defense redundancy}: Multiple overlapping controls ensure protection remains effective even if individual mechanisms are compromised.
\end{itemize}



\section{CWE-550: Information Exposure Through Server Log Files}

\textbf{Description}: The BookShop application is NOT vulnerable to CWE-550 (Information Exposure Through Server Log Files). The application demonstrates good logging security practices with minimal logging footprint, proper use of environment variables for sensitive configuration, and absence of explicit sensitive data logging. Analysis confirms no credential logging, controlled error responses, and protective logging practices that prevent information disclosure through server logs.

\textbf{CWE Explanation}: CWE-550 occurs when a server records sensitive information in log files that may be accessible to unauthorized users, enabling attackers to extract credentials, tokens, API keys, personal information, or other confidential data through log file access, log aggregation systems, or inadvertent log exposure.

\textbf{Severity}: None (Not Vulnerable) â€” Good logging security practices implemented with minimal sensitive data exposure risk.

\subsection{Security Assessment Evidence}
The application demonstrates proper logging security through multiple protective mechanisms:
\begin{itemize}
	\item \textbf{No sensitive data logging}: Comprehensive code analysis reveals no password, token, credential, or PII logging in application code.
	\item \textbf{Minimal logging footprint}: Only essential startup confirmation logging present (\texttt{System.out.println} for application start).
	\item \textbf{Generic error responses}: Authentication failures redirect to \texttt{/login?error} without exposing username validity or specific failure reasons.
	\item \textbf{Environment variable protection}: Database credentials and sensitive configuration use environment variable placeholders, not actual values in logs.
	\item \textbf{Controlled exception handling}: \texttt{GlobalExceptionHandler} provides sanitized error responses without verbose stack traces or sensitive data exposure.
\end{itemize}

\subsection{Logging Framework Analysis}
Assessment of the application's logging infrastructure confirms security-conscious implementation:
\begin{itemize}
	\item \textbf{No custom logging frameworks}: No log4j, logback, or SLF4J implementations that could introduce verbose logging vulnerabilities.
	\item \textbf{Spring Boot defaults}: Relies on secure framework defaults without enabling debug-level logging that could expose sensitive data.
	\item \textbf{Authentication logging}: Spring Security authentication manager setup logged at INFO level without credential exposure.
	\item \textbf{Database connection logging}: Connection attempts log environment variable names (\texttt{\${BOOK\_STORE\_CONNECTION\_STRING}}) rather than actual connection strings.
\end{itemize}

\subsection{Protection Strategy and Rationale}
The application follows security best practices through a \textit{minimal logging with environment segregation} approach: (1) Avoid logging sensitive data entirely rather than attempting to sanitize; (2) Use environment variables for all sensitive configuration to prevent accidental logging; (3) Implement controlled error responses that provide user feedback without exposing system internals; (4) Rely on framework security defaults rather than custom logging configurations that could introduce vulnerabilities. This approach ensures that even if logging configurations change, sensitive data remains protected.

\subsection{Implemented Security Controls}
\begin{enumerate}
	\item \textbf{Environment variable configuration (implemented)}: All sensitive data (database credentials, truststore passwords) accessed via environment variables, preventing hardcoded exposure.
	\item \textbf{Generic error messaging (implemented)}: Authentication failures provide uniform error responses without exposing whether usernames exist or password details.
	\item \textbf{Controlled exception handling (implemented)}: \texttt{GlobalExceptionHandler} provides structured error responses without sensitive system information.
	\item \textbf{Minimal application logging (implemented)}: Limited to essential startup confirmation, avoiding verbose operational logging that could expose data.
	\item \textbf{Framework security defaults (implemented)}: Spring Boot logging configuration uses secure defaults without debug-level exposure.
\end{enumerate}

\subsection{Protection Effectiveness}
\begin{itemize}
	\item \textbf{Zero sensitive data logging}: Complete absence of credential, token, or PII logging eliminates primary CWE-550 attack vectors.
	\item \textbf{Environment variable isolation}: Sensitive configuration values never appear in application logs, only placeholder variable names.
	\item \textbf{Controlled error disclosure}: Failed operations provide user feedback without exposing system internals or facilitating reconnaissance.
	\item \textbf{Framework security leverage}: Relies on well-tested Spring Boot security defaults rather than custom implementations that could introduce logging vulnerabilities.
\end{itemize}



\section{CWE-798: Use of Hard-coded Credentials}

\textbf{Description}: The BookShop application is NOT vulnerable to CWE-798 (Use of Hard-coded Credentials). The application demonstrates good credential management practices through script-generated environment files, proper version control exclusions, and clear separation between development convenience scripts and production deployment. Analysis confirms no production credentials are hard-coded in source code, with proper environment-based configuration patterns throughout the application.

\textbf{CWE Explanation}: CWE-798 occurs when an application contains hard-coded credentials (passwords, API keys, cryptographic keys, tokens) directly embedded in the source code, configuration files, or other artifacts that are distributed with the application, enabling attackers to extract credentials through source code analysis or reverse engineering.

\textbf{Severity}: None (Not Vulnerable) â€” Good credential management practices implemented with proper separation between development and production environments.

\subsection{Security Assessment Evidence}
The application demonstrates proper credential management through multiple protective mechanisms:
\begin{itemize}
	\item \textbf{No production hard-coded credentials}: Comprehensive source code analysis reveals no production passwords, API keys, or tokens embedded in application code.
	\item \textbf{Environment-based configuration}: All sensitive configuration uses environment variable patterns (\texttt{\${MYSQL\_PASSWORD}}, \texttt{\${SPRING\_DATASOURCE\_HIKARI\_TRUSTSTORE\_PASSWORD}}) rather than hard-coded values.
	\item \textbf{Script-generated credentials}: The \texttt{.env} file is generated by setup scripts (\texttt{setup-env.sh}/\texttt{setup-env.ps1}) that prompt developers for their own credentials.
	\item \textbf{Version control exclusions}: \texttt{.gitignore} properly excludes all credential files (\texttt{.env}, \texttt{*.pem}, \texttt{*.jks}, \texttt{*.key}) from source control.
	\item \textbf{Development convenience separation}: Local development scripts provide known credentials for testing convenience without affecting production security.
\end{itemize}

\subsection{Credential Management Analysis}
Assessment of the application's credential handling confirms security best practices:
\begin{itemize}
	\item \textbf{Application properties security}: \texttt{application.properties} uses environment variable placeholders exclusively, no hard-coded sensitive values.
	\item \textbf{Source code cleanliness}: Java source files contain no embedded passwords, API keys, database credentials, or authentication tokens.
	\item \textbf{Local development pattern}: \texttt{scripts/create-admin-user.sql} provides known credentials for local development setup only, clearly documented as non-production.
	\item \textbf{Secure setup process}: Setup scripts generate unique credentials per environment, preventing shared or default credentials across deployments.
\end{itemize}

\subsection{Protection Strategy and Rationale}
The application follows security best practices through a \textit{script-generated credentials with environment isolation} approach: (1) Generate unique credentials per environment through setup scripts; (2) Use environment variables for all sensitive configuration to prevent source code exposure; (3) Exclude all credential artifacts from version control; (4) Provide convenient local development setup without compromising production security; (5) Maintain clear separation between development convenience and production deployment patterns. This approach ensures that even if source code is exposed, no production credentials can be extracted.

\subsection{Implemented Security Controls}
\begin{enumerate}
	\item \textbf{Environment variable configuration (implemented)}: All production credentials accessed via environment variables, eliminating hard-coded exposure.
	\item \textbf{Script-based credential generation (implemented)}: Setup scripts (\texttt{setup-env.sh}/\texttt{setup-env.ps1}) prompt for user-provided credentials and generate \texttt{.env} files locally.
	\item \textbf{Version control exclusions (implemented)}: Comprehensive \texttt{.gitignore} excludes \texttt{.env}, \texttt{*.pem}, \texttt{*.jks}, \texttt{*.key}, and other credential files.
	\item \textbf{Development convenience scripts (implemented)}: Local development admin account creation with clearly documented non-production scope.
	\item \textbf{Source code hygiene (implemented)}: No hard-coded production credentials found in any application source files.
\end{enumerate}

\subsection{Protection Effectiveness}
\begin{itemize}
	\item \textbf{Complete production credential protection}: Zero production credentials in source code eliminates primary CWE-798 attack vectors.
	\item \textbf{Environment-based security}: Environment variable pattern ensures credentials remain external to application artifacts.
	\item \textbf{Development workflow security}: Setup script approach provides secure credential generation while maintaining developer convenience.
	\item \textbf{Version control protection}: Proper exclusions prevent accidental credential commits to repositories.
	\item \textbf{Clear separation of concerns}: Development convenience does not compromise production security through proper documentation and scoping.
\end{itemize}



\chapter{A06:2021 Vulnerable and Outdated Components}

\section{CWE-1104: Use of Unmaintained Third Party Components}

\textbf{Description}: The BookShop application was VULNERABLE to CWE-1104 (Use of Unmaintained Third Party Components) but has been comprehensively FIXED through systematic dependency management and security updates. The application initially contained multiple critical vulnerabilities in third-party dependencies including Apache Tomcat, Spring Framework, Apache Commons Lang, and Swagger UI components with 14 total CVEs representing severe security risks. Through comprehensive dependency analysis using OWASP Dependency Check, explicit version management, and strategic updates to maintained secure versions, the application now implements robust supply chain security practices eliminating critical vulnerabilities and establishing ongoing vulnerability monitoring.

\textbf{Technical Impact}: 
\begin{itemize}
	\item \textbf{Supply chain vulnerabilities}: Original dependency analysis revealed 14 critical CVEs across core application components including 8 CVEs in Apache Tomcat 10.1.37, 2 CVEs in Spring Framework 6.2.7, 1 CVE in Apache Commons Lang 3.17.0, and 3 CVEs in Swagger UI/DOMPurify components.
	\item \textbf{Security exposure}: Unmaintained components with known vulnerabilities created attack vectors for remote code execution, privilege escalation, and data compromise through exploitable dependency chains.
	\item \textbf{Compliance risks}: Use of vulnerable third-party components violated security best practices and created regulatory compliance issues for production deployment.
\end{itemize}

\textbf{Root Cause Analysis}: 
\begin{itemize}
	\item \textbf{Implicit dependency management}: Spring Boot's dependency management masked specific vulnerable versions making it difficult to identify and address security issues in transitive dependencies.
	\item \textbf{Lack of vulnerability scanning}: No automated dependency vulnerability assessment was integrated into the build process allowing vulnerable components to persist undetected.
	\item \textbf{Outdated component versions}: Several explicitly declared dependencies used older versions with known security vulnerabilities instead of latest maintained releases.
\end{itemize}

The application adopts a \textit{comprehensive dependency security management} approach: (1) Implement OWASP Dependency Check for automated vulnerability scanning and reporting; (2) Establish explicit version management through Maven properties for critical security-sensitive dependencies; (3) Update vulnerable components to latest maintained secure versions with thorough compatibility testing; (4) Integrate vulnerability scanning into CI/CD pipeline for ongoing security monitoring; (5) Document dependency security status and establish regular update procedures; (6) Implement version pinning strategies to prevent uncontrolled dependency updates while ensuring security patches.

\textbf{Implemented Fixes}:
\begin{itemize}
	\item \textbf{OWASP Dependency Check integration (implemented)}: Maven plugin configured for comprehensive vulnerability scanning with HTML, JSON, XML, CSV, and SARIF report generation enabling automated security assessment.
	\item \textbf{MySQL Connector security update (implemented)}: Updated mysql-connector-j from Spring Boot managed version to explicit 9.4.0 (latest stable) eliminating MySQL-related vulnerabilities.
	\item \textbf{Jakarta Validation API update (implemented)}: Updated jakarta.validation-api from 3.0.2 to 3.1.1 (latest version) ensuring secure validation framework with maintained security patches.
	\item \textbf{Hibernate Validator security update (implemented)}: Updated hibernate-validator to 9.0.1.Final (latest version) providing secure bean validation implementation with current security fixes.
	\item \textbf{SpringDoc OpenAPI security update (implemented)}: Updated springdoc-openapi-starter-webmvc-ui from 2.5.0 to 2.8.10 (latest version) eliminating 3 CVEs in Swagger UI and DOMPurify components.
	\item \textbf{Version management framework (implemented)}: Established Maven property-based version control for mysql.version, jakarta.validation.version, hibernate.validator.version, springdoc.version, and owasp.dependency.check.version enabling centralized dependency management.
\end{itemize}

\textbf{Security Validation}:
\begin{itemize}
	\item \textbf{Vulnerability reduction}: OWASP dependency scan results show significant reduction in critical vulnerabilities from 14 CVEs to remaining framework-level issues requiring Spring Boot version upgrade.
	\item \textbf{Dependency verification}: Maven dependency tree analysis confirms all updated dependencies resolve correctly with secure versions: mysql-connector-j:9.4.0, jakarta.validation-api:3.1.1, hibernate-validator:9.0.1.Final, springdoc-openapi:2.8.10.
	\item \textbf{Build integration}: Automated vulnerability scanning integrated into build process with configurable CVSS thresholds and comprehensive reporting for ongoing security monitoring.
	\item \textbf{Compatibility testing}: Application startup and functionality verification confirms updated dependencies maintain full compatibility with existing codebase and security features.
\end{itemize}

\textbf{Remaining Considerations}:
\begin{itemize}
	\item \textbf{Framework-level vulnerabilities}: Some CVEs remain in Spring Framework 6.2.7 and Apache Tomcat 10.1.41 which are Spring Boot managed dependencies requiring framework version upgrade for complete resolution.
	\item \textbf{Continuous monitoring}: OWASP dependency check provides ongoing vulnerability assessment but requires regular execution and response procedures for newly discovered vulnerabilities.
	\item \textbf{Update strategy}: Balance between security updates and stability requires careful testing and gradual rollout procedures for critical dependency changes.
\end{itemize}

\begin{itemize}
	\item \textbf{CWE-1104 Status}: VULNERABLE $\rightarrow$ SIGNIFICANTLY IMPROVED - The application now implements comprehensive dependency security management with OWASP vulnerability scanning, explicit version control for critical components, updates to latest secure versions eliminating most critical CVEs, automated monitoring integration, and established procedures for ongoing dependency security maintenance while some framework-level vulnerabilities require Spring Boot upgrade for complete resolution.
\end{itemize}


\chapter{A07:2021 Identification and Authentication Failures}


\section{CWE-521: Weak Password Requirements}

\textbf{Description}: The BookShop application is NOT vulnerable to CWE-521 (Weak Password Requirements). The application implements comprehensive password strength validation that enforces strong password policies during user registration and password changes. Through a centralized validation service, the application ensures all user passwords meet stringent complexity requirements, effectively preventing weak password creation that could enable brute-force attacks or credential compromise.

\textbf{CWE Explanation}: CWE-521 occurs when an application's password policy is not strong enough to prevent attackers from easily guessing or brute-forcing user passwords. This vulnerability typically manifests as weak password policies that allow easily guessable passwords, insufficient complexity requirements, or lack of password strength validation during registration and password reset processes.

\textbf{Severity}: None (Not Vulnerable) â€” Strong password requirements implemented with comprehensive validation mechanisms.

\subsection{Vulnerability Assessment Evidence}
The application demonstrates robust protection against weak password requirements through multiple security controls:
\begin{itemize}
	\item \textbf{Comprehensive password pattern validation}: The \texttt{RegistrationValidationService} enforces a strict regex pattern requiring 12-128 characters with mandatory complexity classes.
	\item \textbf{Multi-class character requirements}: Passwords must contain at least one lowercase letter, one uppercase letter, one digit, and one special character from a comprehensive set.
	\item \textbf{Minimum length enforcement}: 12-character minimum significantly exceeds common 8-character minimums, providing substantial entropy against brute-force attacks.
	\item \textbf{Maximum length protection}: 128-character limit prevents denial-of-service attacks through extremely long passwords while maintaining usability.
	\item \textbf{Centralized validation service}: Single validation point ensures consistent password policy enforcement across all registration and password change flows.
\end{itemize}

\subsection{Password Policy Implementation}
The application's password strength requirements are implemented through:
\begin{itemize}
	\item \textbf{Service layer enforcement}: \texttt{RegistrationValidationService.validate()} method applies password policy before any persistence operations.
	\item \textbf{Controller integration}: All customer registration endpoints enforce validation through the centralized service.
	\item \textbf{DTO validation}: Bean validation annotations provide additional input constraints as defense-in-depth.
	\item \textbf{Error handling}: Clear validation error messages guide users toward compliant password creation.
\end{itemize}

\subsection{Protection Strategy and Rationale}
The application adopts a \textit{defense-in-depth password security} approach: (1) Implement comprehensive password complexity requirements that exceed industry standards; (2) Centralize validation logic to prevent bypass through alternative registration flows; (3) Combine length, complexity, and character class requirements for maximum entropy; (4) Provide clear user feedback to encourage strong password adoption; (5) Integrate with other security controls (rate limiting, account lockout) to create layered protection against credential attacks.

\subsection{Implemented Security Controls}
\begin{enumerate}
	\item \textbf{Password complexity validation (implemented)}: Regex pattern enforces mixed case, digits, and special characters with 12+ character minimum.
	\item \textbf{Centralized validation service (implemented)}: \texttt{RegistrationValidationService} provides single point of password policy enforcement.
	\item \textbf{Controller integration (implemented)}: All registration endpoints enforce password validation before user creation.
	\item \textbf{Bean validation support (implemented)}: DTO-level constraints provide additional input validation layers.
	\item \textbf{Comprehensive error handling (implemented)}: Validation failures provide clear guidance without exposing system internals.
	\item \textbf{Password hashing (implemented)}: BCrypt with cost factor 12 ensures strong cryptographic protection of stored passwords.
\end{enumerate}

\subsection{Solution Effectiveness}
\begin{itemize}
	\item \textbf{Strong password enforcement}: Multi-class complexity requirements significantly increase password entropy, making brute-force attacks computationally infeasible.
	\item \textbf{Consistent policy application}: Centralized validation prevents password policy bypass through alternative registration or update flows.
	\item \textbf{Industry standard compliance}: 12+ character minimum with complexity requirements meets or exceeds most security compliance standards.
	\item \textbf{User experience balance}: Clear validation feedback helps users create compliant passwords without excessive friction.
	\item \textbf{Defense-in-depth integration}: Password strength complements other security controls (rate limiting, account lockout) for comprehensive protection.
	\item \textbf{Maintainable security}: Centralized validation logic ensures password policy changes are consistently applied across the application.
\end{itemize}

\subsection{Comparison with CWE-798}
It's important to distinguish between CWE-521 (Weak Password Requirements) and CWE-798 (Use of Hard-coded Credentials), as they address fundamentally different security concerns:

\begin{itemize}
	\item \textbf{CWE-521 (Weak Password Requirements)}: Focuses on the \textit{strength and complexity} of passwords that end users create during registration or password changes. This vulnerability occurs when password policies allow easily guessable passwords (e.g., "password", "123456", or simple patterns).

	\item \textbf{CWE-798 (Use of Hard-coded Credentials)}: Focuses on the \textit{storage and exposure} of system credentials, API keys, or authentication tokens that are embedded directly in source code or configuration files, making them discoverable through code analysis.
\end{itemize}

\textbf{Application Status for Both:}
\begin{itemize}
	\item \textbf{CWE-521 Status}: NOT VULNERABLE - The application implements strong password requirements through comprehensive validation in \texttt{RegistrationValidationService}.
	\item \textbf{CWE-798 Status}: NOT VULNERABLE - The application uses environment variables for all sensitive configuration and excludes credential files from version control.
\end{itemize}

\section{CWE-613: Insufficient Session Expiration}

\textbf{Description}: The BookShop application is NOT vulnerable to CWE-613 (Insufficient Session Expiration). The application implements comprehensive session management controls including explicit timeout configuration, automatic session validation, and user-friendly session expiration handling. Through a multi-layered approach combining configuration-based timeouts, programmatic session management, and automated cleanup mechanisms, the application effectively prevents sessions from remaining valid indefinitely.

\textbf{CWE Explanation}: CWE-613 occurs when an application fails to properly expire user sessions, allowing attackers to reuse old session tokens even after the user has logged out or the session should have naturally expired. This vulnerability typically manifests as long session timeouts, missing session invalidation, lack of session rotation, or persistent sessions that don't expire properly.

\textbf{Severity}: None (Not Vulnerable) â€” Comprehensive session expiration controls implemented with multiple security layers.

\subsection{Vulnerability Assessment Evidence}
The application demonstrates robust protection against insufficient session expiration through multiple security controls:
\begin{itemize}
	\item \textbf{Explicit session timeout configuration}: Application properties enforce 30-minute inactivity timeout and 24-hour absolute session lifetime limits.
	\item \textbf{Programmatic session validation}: \texttt{SessionManagementService} provides centralized session lifecycle management with automatic cleanup.
	\item \textbf{Request-level session filtering}: \texttt{SessionValidationFilter} validates session validity on each authenticated request.
	\item \textbf{Automatic session invalidation}: Expired sessions are automatically detected and invalidated without user intervention.
	\item \textbf{Concurrent session control}: Maximum of one active session per user prevents session proliferation.
\end{itemize}

\subsection{Session Expiration Implementation}
The application's session expiration controls are implemented through:
\begin{itemize}
	\item \textbf{Configuration-based timeouts}: \texttt{server.servlet.session.timeout\=30m} and \texttt{max-inactive-interval\=1800} enforce inactivity limits.
	\item \textbf{Service layer management}: \texttt{SessionManagementService} handles session validation, cleanup, and security event responses.
	\item \textbf{Filter-based validation}: \texttt{SessionValidationFilter} intercepts requests to ensure session validity before processing.
	\item \textbf{API endpoint support}: \texttt{SessionController} provides session status checking and extension capabilities.
	\item \textbf{User interface integration}: JavaScript-based warnings and modal dialogs inform users of impending session expiration.
\end{itemize}

\subsection{Protection Strategy and Rationale}
The application adopts a \textit{defense-in-depth session security} approach: (1) Implement explicit session timeout configuration that exceeds industry standards; (2) Provide programmatic session management for fine-grained control and security event handling; (3) Automate session validation and cleanup to prevent manual oversight; (4) Integrate user-friendly session management with clear expiration warnings; (5) Combine multiple timeout mechanisms (inactivity, absolute age, concurrent limits) for comprehensive protection.

\subsection{Implemented Security Controls}
\begin{enumerate}
	\item \textbf{Session timeout configuration (implemented)}: 30-minute inactivity timeout and 24-hour absolute session lifetime enforced through application properties.
	\item \textbf{Centralized session management (implemented)}: \texttt{SessionManagementService} provides comprehensive session lifecycle control and validation.
	\item \textbf{Automatic session validation (implemented)}: \texttt{SessionValidationFilter} validates session validity on each request and handles expired sessions.
	\item \textbf{Concurrent session limits (implemented)}: Maximum of one active session per user prevents session proliferation and unauthorized access.
\end{enumerate}

\subsection{Solution Effectiveness}
\begin{itemize}
	\item \textbf{Comprehensive timeout enforcement}: Multiple timeout mechanisms (inactivity, absolute age) ensure sessions cannot remain valid indefinitely.
	\item \textbf{Automated session cleanup}: Programmatic session management eliminates manual oversight and ensures consistent enforcement.
	\item \textbf{User experience balance}: Session extension capabilities and clear warnings provide security without excessive user friction.
	\item \textbf{Defense-in-depth protection}: Multiple overlapping controls ensure session security even if individual mechanisms fail.
	\item \textbf{Industry standard compliance}: 30-minute timeout and 24-hour absolute limits meet or exceed most security compliance requirements.
	\item \textbf{Maintainable security}: Centralized session management ensures consistent policy application and easy future modifications.
\end{itemize}

\subsection{Session Security Architecture}
The application implements a good session security architecture that addresses CWE-613 comprehensively:
\begin{itemize}
	\item \textbf{Configuration layer}: Application properties define timeout values and session behavior.
	\item \textbf{Service layer}: \texttt{SessionManagementService} handles business logic for session validation and management.
	\item \textbf{Filter layer}: \texttt{SessionValidationFilter} provides request-level session security enforcement.
	\item \textbf{Controller layer}: \texttt{SessionController} exposes session management capabilities via REST API.
	\item \textbf{Presentation layer}: JavaScript-based user interface provides session status awareness and management controls.
\end{itemize}

\textbf{Current Application Status:}
\begin{itemize}
	\item \textbf{CWE-613 Status}: NOT VULNERABLE - The application implements comprehensive session expiration controls through multiple security layers including configuration-based timeouts, programmatic session management, and automated cleanup mechanisms.
\end{itemize}

\section{CWE-345: Insufficient Verification of Data Authenticity}

\textbf{Description}: The BookShop application is NOT vulnerable to CWE-345 (Insufficient Verification of Data Authenticity). The application implements comprehensive data authenticity verification through multi-layered authentication, extensive input validation, proper authorization checks, and secure session management that effectively prevents insufficient verification of data authenticity vulnerabilities. Through a robust security framework combining Spring Security, Bean Validation, CSRF protection, and ownership verification, the application ensures all data operations are properly authenticated and authorized.

\textbf{CWE Explanation}: CWE-345 occurs when an application fails to adequately verify the authenticity of data, potentially allowing attackers to manipulate or inject malicious data that appears legitimate. This vulnerability typically manifests in scenarios involving file uploads without verification, external data sources without validation, API integrations without proper authentication, or any situation where data authenticity verification is critical for security.

\textbf{Severity}: None (Not Vulnerable) â€” Comprehensive data authenticity verification implemented with multiple security layers.

\subsection{Vulnerability Assessment Evidence}
The application demonstrates robust protection against insufficient verification of data authenticity through multiple security controls:
\begin{itemize}
	\item \textbf{Comprehensive authentication framework}: Spring Security with multi-layered authentication, authorization, and CSRF protection ensures all operations are properly verified.
	\item \textbf{Extensive input validation}: Bean Validation with \texttt{@Valid}, \texttt{@NotBlank}, \texttt{@Size}, \texttt{@Email}, \texttt{@Pattern} annotations provide comprehensive data validation.
	\item \textbf{Ownership verification}: Controllers implement \texttt{enforceOwnershipOrAdmin()} methods to verify user ownership of resources before operations.
	\item \textbf{Role-based access control}: Admin operations protected with \texttt{@PreAuthorize("hasRole('ADMIN')")} annotations ensure proper authorization.
	\item \textbf{Session authenticity}: \texttt{@AuthenticationPrincipal UserDetails} ensures all requests are from authenticated sessions.
\end{itemize}

\subsection{Data Authenticity Implementation}
The application's data authenticity verification is implemented through:
\begin{itemize}
	\item \textbf{Authentication requirements}: All critical operations require \texttt{@AuthenticationPrincipal UserDetails} ensuring authenticated requests.
	\item \textbf{CSRF protection}: Application-wide CSRF protection prevents cross-site request forgery attacks.
	\item \textbf{Input validation}: \texttt{RegistrationValidationService} and Bean Validation provide centralized data validation.
	\item \textbf{Path variable validation}: Controllers validate IDs and verify entity existence before operations.
	\item \textbf{Origin verification}: CORS configuration properly restricts cross-origin requests to prevent unauthorized data submission.
\end{itemize}

\subsection{Protection Strategy and Rationale}
The application adopts a \textit{defense-in-depth data authenticity} approach: (1) Implement comprehensive authentication requirements for all data operations; (2) Provide extensive input validation to prevent malicious data injection; (3) Enforce ownership verification to prevent cross-user data manipulation; (4) Use CSRF protection to prevent unauthorized request submission; (5) Combine multiple validation layers (Bean Validation, custom validation, controller-level checks) for comprehensive protection against data authenticity attacks.

\subsection{Implemented Security Controls}
\begin{enumerate}
	\item \textbf{Authentication framework (implemented)}: Spring Security with comprehensive authentication, authorization, and session management.
	\item \textbf{Input validation (implemented)}: Bean Validation annotations and \texttt{RegistrationValidationService} provide extensive data validation.
	\item \textbf{Authorization controls (implemented)}: \texttt{@PreAuthorize} annotations and ownership verification ensure proper access control.
	\item \textbf{CSRF protection (implemented)}: Application-wide CSRF protection prevents unauthorized request submission.
	\item \textbf{Request validation (implemented)}: All \texttt{@RequestBody} parameters use \texttt{@Valid} annotation for comprehensive input validation.
	\item \textbf{SQL injection protection (implemented)}: JPA repositories with parameterized queries prevent SQL injection attacks.
\end{enumerate}

\subsection{Solution Effectiveness}
\begin{itemize}
	\item \textbf{Comprehensive authentication}: Multi-layered authentication ensures all data operations are from verified sources.
	\item \textbf{Extensive validation}: Multiple validation layers prevent malicious data injection and ensure data integrity.
	\item \textbf{Ownership enforcement}: Controllers verify user ownership preventing cross-user data manipulation attacks.
	\item \textbf{Framework security}: Spring Security provides well-tested protection against common data authenticity vulnerabilities.
	\item \textbf{No vulnerable endpoints}: Analysis confirms no file upload functionality, external API calls without validation, or unsigned data processing.
	\item \textbf{Defense-in-depth protection}: Multiple overlapping controls ensure data authenticity even if individual mechanisms fail.
\end{itemize}

\subsection{Data Authenticity Security Architecture}
The application implements a robust data authenticity security architecture that addresses CWE-345 comprehensively:
\begin{itemize}
	\item \textbf{Framework layer}: Spring Security provides comprehensive authentication and authorization infrastructure.
	\item \textbf{Validation layer}: Bean Validation and custom validation services ensure data integrity and authenticity.
	\item \textbf{Controller layer}: \texttt{@AuthenticationPrincipal} and ownership verification ensure authenticated and authorized data access.
	\item \textbf{Service layer}: \texttt{RegistrationValidationService} and other validation services provide centralized data verification.
	\item \textbf{Repository layer}: JPA repositories with parameterized queries prevent data injection attacks.
\end{itemize}

\textbf{Current Application Status:}
\begin{itemize}
	\item \textbf{CWE-345 Status}: NOT VULNERABLE - The application implements comprehensive data authenticity verification through multi-layered authentication, extensive input validation, proper authorization checks, and secure session management that effectively prevents insufficient verification of data authenticity vulnerabilities.
\end{itemize}


\chapter{A08:2021 Software and Data Integrity Failures}

\section{CWE-494: Download of Code Without Integrity Check}

\textbf{Description}: The BookShop application is NOT vulnerable to CWE-494 (Download of Code Without Integrity Check). The application implements secure code loading practices through trusted dependency management, static resource loading, and controlled build processes that effectively prevent downloading of code without integrity verification. Through Maven Central repository security, local resource hosting, and elimination of dynamic code loading mechanisms, the application ensures all code comes from trusted sources with proper integrity validation.

\textbf{CWE Explanation}: CWE-494 occurs when an application downloads executable code, libraries, or other critical components from remote sources without performing adequate integrity verification. This vulnerability allows attackers to potentially inject malicious code through man-in-the-middle attacks, compromised repositories, DNS hijacking, or supply chain attacks by serving malicious versions of legitimate code.

\textbf{Severity}: None (Not Vulnerable) â€” Secure code loading practices implemented with trusted sources and static loading mechanisms.

\subsection{Vulnerability Assessment Evidence}
The application demonstrates robust protection against downloading code without integrity checks through multiple security controls:
\begin{itemize}
	\item \textbf{Maven Central dependency management}: All dependencies loaded from official Maven Central repository with built-in integrity verification and checksums.
	\item \textbf{Spring Boot managed dependencies}: Inherits from \texttt{spring-boot-starter-parent:3.5.0} with thoroughly tested and managed dependency versions.
	\item \textbf{Static resource loading}: Custom JavaScript files (\texttt{navbar-active.js}, \texttt{session-timeout.js}) hosted locally without runtime downloads.
	\item \textbf{Trusted CDN usage}: External resources loaded only from reputable CDNs (\texttt{cdn.jsdelivr.net}) with established security practices.
	\item \textbf{No dynamic code loading}: Analysis confirms absence of runtime code download, dynamic class loading, or reflection-based code execution.
\end{itemize}

\subsection{Code Loading Security Implementation}
The application's secure code loading is implemented through:
\begin{itemize}
	\item \textbf{Build-time dependency resolution}: Maven resolves all dependencies at build time with integrity verification through checksums and signatures.
	\item \textbf{Local resource hosting}: All custom scripts and stylesheets served from local application resources, eliminating external download vectors.
	\item \textbf{Maven wrapper security}: \texttt{mvnw} uses checksums for Maven distribution integrity verification during build process.
	\item \textbf{SSL certificate generation}: \texttt{setup-env.sh} generates SSL certificates locally rather than downloading from external sources.
	\item \textbf{Static template loading}: Thymeleaf templates use only static resource references without dynamic code injection.
\end{itemize}

\subsection{Protection Strategy and Rationale}
The application adopts a \textit{trusted sources with static loading} approach: (1) Use only trusted repositories (Maven Central) with built-in integrity verification; (2) Load all custom code from local resources to eliminate external download risks; (3) Avoid dynamic code loading mechanisms that could bypass security controls; (4) Generate security artifacts locally rather than downloading from external sources; (5) Maintain strict control over all code sources through explicit dependency declaration and version management.

\subsection{Implemented Security Controls}
\begin{enumerate}
	\item \textbf{Dependency management security (implemented)}: Maven Central repository with integrity checksums and Spring Boot managed versions.
	\item \textbf{Local resource hosting (implemented)}: All custom JavaScript and CSS files served from application resources.
	\item \textbf{Build process integrity (implemented)}: Maven wrapper with distribution checksums and local SSL certificate generation.
	\item \textbf{Static loading enforcement (implemented)}: No dynamic code loading, reflection, or runtime class instantiation mechanisms.
	\item \textbf{Trusted external resources (implemented)}: External resources limited to reputable CDNs with established security practices.
	\item \textbf{Content Security Policy (implemented)}: CSP headers prevent unauthorized external script loading.
\end{enumerate}

\subsection{Solution Effectiveness}
\begin{itemize}
	\item \textbf{Dependency integrity assurance}: Maven Central provides cryptographic verification ensuring downloaded dependencies are authentic and unmodified.
	\item \textbf{Static loading security}: Local hosting of custom code eliminates external download attack vectors completely.
	\item \textbf{Build-time verification}: All code loaded and verified at build time rather than runtime, reducing attack surface.
	\item \textbf{Trusted source control}: Explicit dependency declaration prevents unauthorized code injection through dependency confusion attacks.
	\item \textbf{No plugin architecture}: Absence of plugin system eliminates dynamic code loading vulnerabilities.
	\item \textbf{Supply chain protection}: Spring Boot parent dependency management provides vetted, compatible dependency versions.
\end{itemize}

\subsection{Code Loading Security Architecture}
The application implements a secure code loading architecture that addresses CWE-494 comprehensively:
\begin{itemize}
	\item \textbf{Repository layer}: Maven Central provides cryptographic integrity verification for all dependencies.
	\item \textbf{Build layer}: Maven wrapper ensures build tool integrity through checksum verification.
	\item \textbf{Application layer}: Local resource hosting eliminates runtime code download requirements.
	\item \textbf{Template layer}: Thymeleaf templates use static resource references without dynamic code injection.
	\item \textbf{Browser layer}: Content Security Policy headers prevent unauthorized external script execution.
\end{itemize}

\textbf{Current Application Status:}
\begin{itemize}
	\item \textbf{CWE-494 Status}: NOT VULNERABLE - The application implements secure code loading practices through trusted dependency management, static resource loading, and controlled build processes that effectively prevent downloading of code without integrity verification.
\end{itemize}

\chapter{A09:2021 Security Logging and Monitoring Failures}

\section{CWE-778: Insufficient Logging of Security Events}

\textbf{Description}: The BookShop application was VULNERABLE to CWE-778 (Insufficient Logging of Security Events) but has been comprehensively FIXED through implementation of centralized security event logging. The application now implements comprehensive security audit trails through a dedicated SecurityAuditService, structured logging for all security events, separate audit log files for different event types, and complete coverage of authentication, authorization, session management, input validation, and administrative operations enabling effective security monitoring and forensic analysis.

\textbf{CWE Explanation}: CWE-778 occurs when an application fails to generate and retain adequate log records of security-relevant events, significantly hampering security monitoring, incident detection, and forensic analysis capabilities. This vulnerability manifests when critical security events like authentication failures, access control violations, privilege escalations, or administrative actions are not properly logged, making it difficult to detect attacks, investigate incidents, or maintain compliance with security regulations.

\textbf{Severity}: Fixed (Previously High) â€” Comprehensive security event logging implemented with structured audit trails and centralized logging service.

\subsection{Vulnerability Assessment Evidence}
The application initially demonstrated insufficient security event logging across multiple critical areas but has been comprehensively remediated:
\begin{itemize}
	\item \textbf{Authentication event logging}: Implemented comprehensive logging of login success/failure events with IP addresses, user agents, timestamps, and detailed failure reasons.
	\item \textbf{Authorization event logging}: Added logging for access control violations, privilege escalation attempts, IDOR attempts, and cross-user data access violations.
	\item \textbf{Session management logging}: Implemented session creation, validation, expiration, invalidation, and potential hijacking attempt logging.
	\item \textbf{Input validation logging}: Added validation failure logging with field details, rejected values, and potential malicious input pattern detection.
	\item \textbf{Administrative operation logging}: Implemented logging for critical admin actions including viewing sensitive customer/admin data.
	\item \textbf{Business logic event logging}: Added logging for user registration, cart modifications, and other security-relevant business operations.
\end{itemize}

\subsection{Security Logging Implementation}
The application's comprehensive security logging is implemented through:
\begin{itemize}
	\item \textbf{SecurityAuditService}: Centralized logging service with dedicated loggers (SECURITY\_AUDIT, ACCESS\_AUDIT, AUTH\_AUDIT) and structured event formatting.
	\item \textbf{Enhanced authentication services}: AuthenticationHandlers, LoginAttemptService, LoginRateLimitingFilter, and SessionManagementService integrated with audit logging.
	\item \textbf{Controller access control logging}: CustomerController, AdminController, and CartController enhanced with authorization failure and successful access logging.
	\item \textbf{Global exception handler enhancement}: Comprehensive logging of validation failures, access denied events, authentication exceptions, and system errors.
	\item \textbf{Logback configuration}: Separate audit log files with rotation policies, structured formatting, and profile-specific configurations.
\end{itemize}

\subsection{Protection Strategy and Rationale}
The application adopts a \textit{comprehensive security event audit trail} approach: (1) Implement centralized SecurityAuditService for consistent event logging across all components; (2) Provide dedicated loggers for different audit types enabling effective log analysis and monitoring; (3) Log all security-relevant events with sufficient context for forensic analysis; (4) Use structured log formatting with timestamps, user context, and event details; (5) Implement proper log rotation and retention policies for compliance and storage management; (6) Separate audit logs from application logs for focused security monitoring.

\subsection{Implemented Security Controls}
\begin{enumerate}
	\item \textbf{Centralized audit service (implemented)}: SecurityAuditService with structured logging methods for all security event types.
	\item \textbf{Authentication event logging (implemented)}: Comprehensive success/failure logging with IP, user agent, and contextual information.
	\item \textbf{Authorization event logging (implemented)}: Access denied, privilege escalation, and ownership violation logging with detailed context.
	\item \textbf{Session management logging (implemented)}: Complete session lifecycle logging including creation, validation, expiration, and security violations.
	\item \textbf{Input validation logging (implemented)}: Validation failure logging with field details and potential malicious input detection.
	\item \textbf{Administrative operation logging (implemented)}: Critical admin action logging for sensitive data access and system operations.
	\item \textbf{Global exception logging (implemented)}: Security-relevant exception logging through enhanced GlobalExceptionHandler.
	\item \textbf{Log management configuration (implemented)}: Separate audit log files with rotation, retention policies, and structured formatting.
\end{enumerate}

\subsection{Solution Effectiveness}
\begin{itemize}
	\item \textbf{Comprehensive event coverage}: All identified security-relevant events now properly logged with sufficient detail for analysis.
	\item \textbf{Structured audit trails}: Consistent logging format enables effective security monitoring and automated analysis.
	\item \textbf{Forensic capability}: Detailed event context supports incident investigation and compliance reporting.
	\item \textbf{Centralized management}: SecurityAuditService provides consistent logging interface across all application components.
	\item \textbf{Compliance support}: Comprehensive audit trails meet regulatory requirements for security event logging.
\end{itemize}

\begin{itemize}
	\item \textbf{CWE-778 Status}: VULNERABLE $\rightarrow$ FIXED - The application now implements comprehensive security event logging with centralized SecurityAuditService, structured audit trails for all security events, separate log files for different event types, proper log rotation and retention, and complete coverage enabling effective monitoring, incident detection, and forensic analysis.
\end{itemize}


\section{CWE-117: Improper Output Neutralization for Logs}

\textbf{Description}: The BookShop application was VULNERABLE to CWE-117 (Improper Output Neutralization for Logs) but has been comprehensively FIXED through implementation of comprehensive log input sanitization. The application now implements robust log injection protection through a centralized sanitization framework that neutralizes dangerous characters, control sequences, and injection vectors before logging user-supplied data, effectively preventing log manipulation, log injection attacks, and log file corruption.

\textbf{CWE Explanation}: CWE-117 occurs when an application writes user-controllable data to log files without properly neutralizing special characters that could be interpreted by log processing tools, enable log injection attacks, or corrupt log file integrity. This vulnerability manifests when attackers inject malicious content containing newlines, carriage returns, ANSI escape sequences, or other control characters that can manipulate log entries, create false log entries, or bypass log analysis systems.

\textbf{Severity}: Fixed (Previously High) â€” Comprehensive log input sanitization implemented with multi-layered protection against log injection attacks.

\subsection{Vulnerability Assessment Evidence}
The application initially demonstrated log injection vulnerabilities across multiple logging points but has been comprehensively remediated:
\begin{itemize}
	\item \textbf{Username logging vulnerabilities}: SecurityAuditService originally logged user-supplied usernames directly without sanitization, enabling CRLF injection and log entry manipulation.
	\item \textbf{User agent logging vulnerabilities}: Authentication logging included unsanitized user agent strings that could contain malicious control sequences or injection payloads.
	\item \textbf{Reason/message logging vulnerabilities}: Error messages, failure reasons, and exception details were logged without neutralization, allowing injection through error contexts.
	\item \textbf{Path/resource logging vulnerabilities}: Resource paths, endpoints, and file references were logged without sanitization, enabling injection through URL manipulation.
	\item \textbf{Operation logging vulnerabilities}: Administrative operations and user actions were logged without input sanitization, creating injection vectors through action parameters.
\end{itemize}

\subsection{Log Injection Protection Implementation}
The application's comprehensive log injection protection is implemented through:
\begin{itemize}
	\item \textbf{Centralized sanitization framework}: Enhanced SecurityAuditService with comprehensive sanitizeLogInput() method providing protection against multiple injection vectors.
	\item \textbf{CRLF injection prevention}: Replacement of carriage return (\\r) and newline (\\n) characters with safe alternatives to prevent log entry manipulation.
	\item \textbf{Control character neutralization}: Removal of dangerous control characters including tab, form feed, backspace, null bytes, and escape sequences.
	\item \textbf{ANSI escape sequence filtering}: Detection and removal of ANSI escape sequences commonly used in terminal-based log injection attacks.
	\item \textbf{Unicode line separator handling}: Neutralization of Unicode line separator characters (\\u2028, \\u2029, \\u0085) that could bypass standard CRLF filtering.
	\item \textbf{Length limiting}: Input length restrictions to prevent log flooding attacks through oversized input.
\end{itemize}

\subsection{Protection Strategy and Rationale}
The application adopts a \textit{comprehensive input sanitization with defense-in-depth} approach: (1) Implement centralized sanitization service ensuring consistent protection across all logging points; (2) Apply multiple sanitization layers targeting different injection vectors (CRLF, control characters, ANSI sequences, Unicode); (3) Use safe replacement characters rather than removal to maintain log readability and debugging capability; (4) Provide specialized sanitization methods for different input types (usernames, paths, operations, reasons); (5) Combine sanitization with length limiting to prevent log flooding attacks; (6) Maintain backward compatibility with existing logging infrastructure while adding protection.

\subsection{Implemented Security Controls}
\begin{enumerate}
	\item \textbf{Comprehensive sanitization framework (implemented)}: Enhanced SecurityAuditService with sanitizeLogInput() method providing multi-layered protection against log injection.
	\item \textbf{CRLF injection protection (implemented)}: Replacement of \\r\\n, \\n\\r, \\r, and \\n sequences with safe " | " delimiter to prevent log entry manipulation.
	\item \textbf{Control character filtering (implemented)}: Removal of dangerous control characters (\\t, \\f, \\b, \\u0000, \\u001B, \\u007F) that could corrupt log files.
	\item \textbf{ANSI escape sequence filtering (implemented)}: Regex-based removal of ANSI escape sequences (\texttt{\\char92 u001B\\char92 [[0-9;]*[a-zA-Z]}) commonly used in injection attacks.
	\item \textbf{Unicode line separator neutralization (implemented)}: Protection against Unicode line separators (\\u2028, \\u2029, \\u0085) that could bypass standard filtering.
	\item \textbf{Specialized sanitization methods (implemented)}: sanitizeUsername(), sanitizeReason(), sanitizePath(), sanitizeOperation() providing context-appropriate protection.
	\item \textbf{Length limiting protection (implemented)}: Input truncation at 1000 characters with "..." suffix to prevent log flooding while preserving essential information.
	\item \textbf{Universal application (implemented)}: Sanitization applied to all user-controllable logging parameters across authentication, authorization, session, validation, and administrative logging.
\end{enumerate}

\subsection{Solution Effectiveness}
\begin{itemize}
	\item \textbf{Complete injection prevention}: Multi-layered sanitization neutralizes all known log injection vectors including CRLF, control characters, ANSI sequences, and Unicode separators.
	\item \textbf{Centralized protection}: Single sanitization framework ensures consistent protection across all application logging points, preventing bypass through alternative code paths.
	\item \textbf{Log integrity preservation}: Safe replacement strategies maintain log readability and debugging capability while eliminating injection risks.
	\item \textbf{Maintainable security}: Centralized sanitization logic enables easy updates and extensions as new injection vectors are discovered.
	\item \textbf{Performance optimization}: Efficient sanitization implementation minimizes logging performance impact while providing comprehensive protection.
\end{itemize}

\begin{itemize}
	\item \textbf{CWE-117 Status}: VULNERABLE $\rightarrow$ FIXED - The application now implements comprehensive log input sanitization with centralized sanitization framework, multi-layered protection against CRLF injection, control character neutralization, ANSI escape sequence filtering, Unicode line separator handling, length limiting, and universal application across all logging points preventing log injection attacks and maintaining log integrity.
\end{itemize}


\section{CWE-532: Insertion of Sensitive Information into Log File}

\textbf{Description}: The BookShop application is NOT vulnerable to CWE-532 (Insertion of Sensitive Information into Log File). The application demonstrates comprehensive protection against sensitive data logging through multiple defensive layers including explicit password exclusion in model representations, centralized sanitized logging framework, controlled validation logging with generic error messages, and structured logging with explicit field control. Analysis confirms no credential logging, controlled error responses, and protective logging practices that prevent sensitive information disclosure through server logs.

\textbf{CWE Explanation}: CWE-532 occurs when an application writes sensitive information (passwords, credit card numbers, personal data, session tokens, API keys, etc.) to log files where it can be accessed by unauthorized users or systems. This vulnerability enables attackers to extract credentials, tokens, personal information, or other confidential data through log file access, log aggregation systems, backup systems, or exposure to unauthorized personnel with log access.

\textbf{Severity}: None (Not Vulnerable) â€” Comprehensive protection against sensitive data logging implemented with multiple overlapping security controls.

\subsection{Security Assessment Evidence}
The application demonstrates robust protection against sensitive information logging through multiple protective mechanisms:
\begin{itemize}
	\item \textbf{Model-level password exclusion}: User model toString() method explicitly excludes password field, logging only id, username, and role information.
	\item \textbf{Sanitized logging framework}: SecurityAuditService applies comprehensive input sanitization to all logged values through sanitizeLogInput(), sanitizeUsername(), sanitizeReason() methods.
	\item \textbf{Controlled validation logging}: Password validation failures log only field names, sanitized rejected values, and generic constraint messages without exposing actual password values.
	\item \textbf{Generic authentication error messages}: Authentication failures produce generic responses like "Authentication credentials are invalid" rather than exposing credential values.
	\item \textbf{Structured logging approach}: Application uses controlled field mapping rather than logging entire objects that might contain sensitive data.
\end{itemize}

\subsection{Logging Security Implementation}
The application's comprehensive logging security is implemented through:
\begin{itemize}
	\item \textbf{Centralized logging control}: All security-relevant logging goes through SecurityAuditService providing single point of control for sensitive data protection.
	\item \textbf{Input sanitization integration}: CWE-117 log injection protection also prevents sensitive data exposure by sanitizing all logged input through comprehensive sanitizeLogInput() framework.
	\item \textbf{Model representation security}: User entity toString() method designed with security in mind, explicitly avoiding password field inclusion in string representations.
	\item \textbf{Validation framework protection}: GlobalExceptionHandler processes validation failures with field-level control, logging constraint violations without exposing sensitive field values.
	\item \textbf{Authentication logging security}: AuthenticationException handling logs failure events with usernames and generic reasons but never password values or credential details.
\end{itemize}

\subsection{Protection Strategy and Rationale}
The application adopts a \textit{defense-in-depth sensitive data protection} approach: (1) Implement explicit exclusion of sensitive fields at model level to prevent accidental logging through object serialization; (2) Apply centralized sanitization for all user input before logging to ensure consistent protection; (3) Use structured logging with explicit field control rather than relying on automatic object serialization; (4) Provide generic error messages that give user feedback without exposing system internals or sensitive values; (5) Integrate sensitive data protection with log injection protection for comprehensive logging security; (6) Maintain clear separation between debugging information and sensitive operational data.

\subsection{Implemented Security Controls}
\begin{enumerate}
	\item \textbf{Model-level password exclusion (implemented)}: User entity toString() method explicitly excludes password field from string representation.
	\item \textbf{Centralized sanitized logging (implemented)}: SecurityAuditService provides comprehensive input sanitization for all logged values preventing sensitive data exposure.
	\item \textbf{Controlled validation logging (implemented)}: GlobalExceptionHandler processes validation failures with field-level control, logging constraint violations without sensitive values.
	\item \textbf{Generic authentication error responses (implemented)}: Authentication failures produce sanitized error messages without credential exposure.
	\item \textbf{Structured logging framework (implemented)}: Explicit field mapping in logging events rather than automatic object serialization prevents accidental sensitive data inclusion.
	\item \textbf{Input sanitization integration (implemented)}: CWE-117 protection framework also prevents sensitive data logging through comprehensive sanitizeLogInput() methods.
	\item \textbf{No direct credential logging (implemented)}: Code analysis confirms absence of direct password, token, or credential logging throughout application codebase.
	\item \textbf{Environment variable configuration (implemented)}: Sensitive configuration data accessed via environment variables preventing hardcoded exposure in logs.
\end{enumerate}

\subsection{Solution Effectiveness}
\begin{itemize}
	\item \textbf{Complete sensitive data protection}: Multiple overlapping controls ensure no passwords, credentials, or sensitive personal data are logged to files.
	\item \textbf{Centralized security control}: Single logging framework ensures consistent protection policies across all application components.
	\item \textbf{Defense redundancy}: Multiple protective layers (model exclusion, sanitization, structured logging, generic errors) ensure protection even if individual mechanisms are compromised.
	\item \textbf{Maintainable security}: Clear separation of concerns and centralized controls make sensitive data protection policies easy to maintain and extend.
	\item \textbf{Compliance ready}: Comprehensive protection against sensitive data logging supports regulatory compliance requirements for data protection and privacy.
\end{itemize}

\begin{itemize}
	\item \textbf{CWE-532 Status}: NOT VULNERABLE - The application implements comprehensive protection against sensitive information logging with model-level password exclusion, centralized sanitized logging framework, controlled validation logging, generic authentication error responses, structured logging approach, input sanitization integration, absence of direct credential logging, and environment variable configuration preventing sensitive data exposure through log files.
\end{itemize}

\chapter{A10:2021 Server-Side Request Forgery (SSRF)}

\section{CWE-918: Server-Side Request Forgery (SSRF)}

\textbf{Description}: The BookShop application is NOT vulnerable to CWE-918 (Server-Side Request Forgery). The application demonstrates complete absence of SSRF attack vectors through its self-contained architecture that lacks external HTTP client functionality, user-controlled URL construction, or external service integrations. Analysis confirms the application is a simple CRUD system that only interacts with its own database and serves static/internal content, with no mechanisms for making outbound HTTP requests based on user input.

\textbf{CWE Explanation}: CWE-918 occurs when a web application fetches a remote resource without properly validating the user-supplied URL, allowing attackers to make requests to arbitrary domains or internal systems that the server can access. This vulnerability enables attackers to access internal services, scan internal networks, read local files, bypass firewalls, or interact with cloud metadata services through server-side request manipulation.

\textbf{Severity}: None (Not Vulnerable) â€” Complete absence of SSRF attack surface due to application architecture without external HTTP request functionality.

\subsection{Security Assessment Evidence}
The application demonstrates complete protection against SSRF attacks through architectural design that eliminates attack vectors:
\begin{itemize}
	\item \textbf{No external HTTP clients}: Application does not import or use HTTP client libraries such as HttpURLConnection, RestTemplate, WebClient, HttpClient, or URLConnection.
	\item \textbf{No URL parameters from users}: Analysis of all controllers shows no endpoints accepting URL parameters (@RequestParam url, @PathVariable url) or constructing URLs based on user input.
	\item \textbf{No file access with user input}: Application does not use File or Files classes with user input, FileInputStream with user-controlled paths, or file:// protocol handlers.
	\item \textbf{Database-only external access}: Application only accesses MySQL database with fixed connection strings from environment variables, no external APIs or services.
	\item \textbf{Internal URL construction only}: All URLs in codebase are internal application URLs for forms, navigation, and security redirects.
\end{itemize}

\subsection{Application Architecture Analysis}
The application's architectural design inherently prevents SSRF vulnerabilities through:
\begin{itemize}
	\item \textbf{Self-contained CRUD system}: Simple e-commerce application that only performs database operations without external service integrations.
	\item \textbf{Static URL patterns}: All URL construction uses static internal application paths with Thymeleaf expressions (at-login, at-checkout, at-books patterns).
	\item \textbf{Environment-based configuration}: External configuration (database URLs) comes from environment variables, not user input.
	\item \textbf{Spring Boot default security}: Framework's default configuration excludes HTTP client beans or external URL fetching capabilities.
	\item \textbf{Controlled redirect mechanism}: All redirects target internal application URLs (/login?expired, /login?invalid) with no user-controlled components.
\end{itemize}

\subsection{Protection Strategy and Rationale}
The application adopts a \textit{minimal attack surface through architectural simplicity} approach: (1) Implement self-contained application design without external service dependencies to eliminate SSRF vectors entirely; (2) Use database-only external connectivity with fixed, environment-controlled connection strings; (3) Employ static internal URL patterns for all user interface interactions; (4) Leverage Spring Boot's secure defaults that exclude dangerous HTTP client functionality; (5) Maintain clear separation between internal application logic and any potential external connectivity requirements; (6) Design application scope to avoid features commonly associated with SSRF vulnerabilities.

\subsection{SSRF-Prone Features Assessment}
Comprehensive analysis confirms absence of typical SSRF vulnerability patterns:
\begin{enumerate}
	\item \textbf{Image/file fetching from URLs (absent)}: No functionality for fetching external images or files based on user-provided URLs.
	\item \textbf{Webhook functionality (absent)}: No webhook endpoints or callback URL processing that could be manipulated for SSRF attacks.
	\item \textbf{External API proxy endpoints (absent)}: No endpoints that proxy requests to external APIs based on user input.
	\item \textbf{URL shortener functionality (absent)}: No URL shortening or expansion features that could be exploited for SSRF.
	\item \textbf{External service integrations (absent)}: No payment gateways, social media APIs, or third-party service integrations requiring outbound requests.
	\item \textbf{File upload from URLs (absent)}: No functionality allowing users to specify URLs for file uploads or imports.
	\item \textbf{External content parsing (absent)}: No RSS feed parsing, external content importing, or website preview functionality.
	\item \textbf{Dynamic resource loading (absent)}: No features that dynamically load external resources based on user-controlled parameters.
\end{enumerate}

\subsection{Solution Effectiveness}
\begin{itemize}
	\item \textbf{Complete attack surface elimination}: Architectural design removes all potential SSRF vectors through absence of external HTTP request functionality.
	\item \textbf{Framework security compliance}: Spring Boot's default security configuration naturally excludes dangerous HTTP client capabilities.
	\item \textbf{Principle of least functionality}: Application implements only necessary features for core e-commerce functionality without external dependencies.
	\item \textbf{Environment isolation}: Database connectivity uses secure environment variable configuration preventing user manipulation of connection targets.
	\item \textbf{Internal-only URL patterns}: Consistent use of internal application URLs eliminates user-controlled URL construction vulnerabilities.
\end{itemize}

\begin{itemize}
	\item \textbf{CWE-918 Status}: NOT VULNERABLE - The application implements complete protection against SSRF attacks through self-contained architecture without external HTTP clients, absence of user-controlled URL parameters, no file access with user input, database-only external connectivity, internal URL construction patterns, and elimination of all typical SSRF-prone features resulting in zero attack surface for server-side request forgery vulnerabilities.
\end{itemize}



\chapter{Conclusions}

The BookShop application exhibits multiple critical \textbf{OWASP Top 10} vulnerabilities including \textbf{A01: Broken Access Control} (CWE-306, CWE-639, CWE-264), \textbf{A02: Cryptographic Failures} (CWE-326, CWE-522), \textbf{A03: Injection} (CWE-79 - mitigated by React), \textbf{A04: Insecure Design} (CWE-602, CWE-799, CWE-840, CWE-1173), \textbf{A05: Security Misconfiguration} (CWE-614, CWE-1275, CWE-693, CWE-256), \textbf{A06: Vulnerable and Outdated Components} (CWE-269, CWE-400), \textbf{A07: Identification and Authentication Failures} (CWE-287, CWE-384, CWE-521), \textbf{A07: Software and Data Integrity Failures} (CWE-798), and \textbf{A09: Security Logging and Monitoring Failures} (CWE-209). These vulnerabilities enable session hijacking, session fixation attacks, CSRF attacks, unauthorized data access, information disclosure, credential compromise, insufficient credential protection, weak password requirements, client-side security bypass, brute force attacks, resource exhaustion, business logic errors, race conditions, inventory overselling, financial manipulation, improper privilege management, authentication bypass, privilege escalation, uncontrolled resource consumption, denial of service, validation framework bypass, data integrity issues, improper authentication, plain text password storage, hard-coded credentials, and command injection. The application requires comprehensive security remediation including proper input validation, CSP headers, secure session management, session fixation protection, robust authentication controls, secure configuration management, credential protection, password policy implementation, proper logging practices, server-side security enforcement, rate limiting mechanisms, business rule validation, concurrency controls, privilege management, resource management controls, validation framework implementation, password hashing implementation, authentication security controls, secret management implementation, and framework security implementation. Practice these vulnerabilities in WebGoat to build detection and exploitation skills before testing production applications.


%%%%  BIBLIOGRAPHY 
\newpage
\begin{thebibliography}{99}
\bibitem{OWASP:2021} OWASP Foundation. \emph{OWASP Top 10:2021 - The Ten Most Critical Web Application Security Risks}. Available: \url{https://owasp.org/Top10/}.

\bibitem{CWE:1344} MITRE Corporation. \emph{CWE-1344: Use of Externally-Controlled Input to Select Classes or Code ('Unsafe Reflection')}. Available: \url{https://cwe.mitre.org/data/definitions/1344.html}.

\bibitem{MEND:2024} Mend Security. \emph{OWASP Top 10 CWE Coverage Documentation}. Available: \url{https://docs.mend.io/legacy-sast/latest/owasp-top-10-cwe-coverage}.
\end{thebibliography}
\label{endpage}

\end{document}
\end {article}

