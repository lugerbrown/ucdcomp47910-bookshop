\documentclass[]{UCD_CS_FYP_Report}
\usepackage{graphicx}
\usepackage{hyperref}

%%%%%%%%%%%%%%%%%%%%%%
%%% Input project details

\def\studentname{Luis Marron (23202882)} % Edit with your name
\def\projecttitle{{\linespread{4.5}\selectfont COMP47910 Secure Software Engineering}} % Edit with you project title
\def\supervisorname{Dr. Liliana Pasquale} % Edit with your supervisor name


\begin{document}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%
%%% Table of Content

\tableofcontents\pdfbookmark[0]{Table of Contents}{toc}\newpage
\newpage

%%%%%%%%%%%%%%%%%%%%%%
%%% Vulnerabilities Fixes Report


\chapter{A01:2021 Broken Access Control}


\section{CWE-284: Improper Access Control}

\textbf{Description}: The BookShop application implements improper access control mechanisms that allow unauthorized users to access restricted functionality and sensitive data. The application lacks proper authentication and authorization checks across multiple endpoints, enabling attackers to bypass security controls and gain unauthorized access to administrative functions and user-specific resources.

\textbf{CWE Explanation}: CWE-284 occurs when the application fails to properly restrict access to functionality or resources, allowing unauthorized users to perform actions or access data that should be protected by proper authentication and authorization mechanisms.

\textbf{Severity}: High

\subsection{Vulnerability Locations and Type}
The application suffered from multiple \textit{Broken / Improper Access Control} weaknesses manifesting as:
\begin{itemize}
	\item \textbf{Vertical privilege escalation}: Security rule protected path pattern \texttt{/admin/**}, while the actual admin endpoint controller was mapped to \texttt{/admins}. This mismatch let any authenticated non-admin invoke administrative endpoints (e.g. \texttt{GET /admins}).
	\item \textbf{Horizontal privilege escalation / Insecure Direct Object Reference (IDOR)}: Cart- and cart-item–related REST endpoints (\texttt{/carts/**}, \texttt{/cart-items/**}) accepted arbitrary \texttt{customerId}, \texttt{cartId}, or \texttt{itemId} without verifying ownership against the authenticated principal, enabling access/modification of other users' carts.
	\item \textbf{Over broad data exposure}: User and customer enumeration endpoints (\texttt{/users/**}, \texttt{/customers/**}) allowed any authenticated user to list or fetch other users/customers and (in the case of \texttt{/users}) returned password hashes, breaching least privilege and confidentiality.
	\item \textbf{Unrestricted modification endpoints}: Book management API (\texttt{books} \texttt{POST} \texttt{PUT} \texttt{DELETE}) was accessible to any authenticated role, permitting non-admin content manipulation.
	\item \textbf{Lack of server side authorization on web cart actions}: Web MVC endpoints for cart item removal did not assert ownership, allowing crafted requests to remove other users' items.
\end{itemize}

\subsection{Mitigation Strategy and Rationale}
Defence-in-depth was applied combining \textbf{path-based authorization}, \textbf{method-level role enforcement}, and \textbf{resource ownership (row-level) checks}. This layered approach ensures:
\begin{itemize}
	\item Misconfigurations in one layer (e.g. path patterns) do not automatically grant access because method-level annotations add a second gate.
	\item Even with correct role checks, horizontal attacks "guessing IDs" are blocked by explicit ownership validation tying domain object identifiers to the authenticated principal "prevents IDOR".
	\item Principle of Least Privilege is restored by scoping sensitive endpoints (admin, user lists, data mutations) strictly to the required roles, reducing attack surface.
	\item Sensitive credential fields are no longer exposed after authorization succeeds, limiting post-auth data leakage channels.
\end{itemize}

\subsection{Implemented Security Controls}
The following concrete changes were introduced in code (branch \texttt{broken-access-control-fixes}):
\begin{enumerate}
	\item \textbf{Corrected admin path mapping}: Updated Spring Security configuration to match the actual controller path \texttt{/admins/**} instead of the incorrect \texttt{/admin/**}.
	\item \textbf{Granular authorization rules}: Added HTTP method specific matchers restricting book mutation endpoints (POST/PUT/DELETE on \texttt{/api/books/**}) and all \texttt{/books/**} (management pages) to role \texttt{ADMIN}. User endpoints \texttt{/users/**} now require \texttt{ADMIN}; customer endpoints enforce authentication plus ownership (see point 3) and reserve modifications for \texttt{ADMIN}.
	\item \textbf{Ownership / row-level checks}: Injected \texttt{@AuthenticationPrincipal} into cart and cart item controllers; added helper methods validating that the referenced cart/item's owning customer's username equals the authenticated principal. Requests failing validation now return HTTP 403 (or 404 when appropriate).
	\item \textbf{Method-level security}: Enabled \texttt{@EnableMethodSecurity} and introduced \texttt{@PreAuthorize} annotations on controller methods (e.g. book mutations, user controller) to provide a second authorization layer beyond URL pattern matching.
	\item \textbf{Data minimisation via DTOs}: Replaced direct entity exposure for users and customers with DTOs omitting the password field and limiting attributes to non-sensitive identification data.
	\item \textbf{Cart web endpoint hardening}: Added ownership validation before allowing removal of a cart item via web MVC endpoint to block cross-user manipulation.
	\item \textbf{Input encapsulation}: Refactored mutable request payload classes (e.g. add-item request) to use private fields with accessors, preventing accidental uncontrolled field exposure (minor hardening).
\end{enumerate}

\subsection{Solution Effectiveness}
The mitigations directly address the CWE-284 root causes:
\begin{itemize}
	\item Path correction + role restrictions close vertical privilege escalation vectors.
	\item Ownership validation eliminates horizontal ID enumeration attacks by binding operations to the authenticated identity.
	\item Method-level annotations safeguard against future path mapping drift or overly broad ant matchers.
	\item DTO-based redaction removes unnecessary sensitive data from responses, shrinking impact radius of any residual access gaps.
	\item Principle of Least Privilege is enforced consistently across both REST and MVC layers, aligning actual access with business intent.
\end{itemize}



\section{CWE-639: Insecure Direct Object References }

	\textbf{Description}: Multiple endpoints previously trusted user-supplied identifiers (e.g. \texttt{customerId}, \texttt{cartId}, \texttt{itemId}) directly to select resources without verifying that the authenticated principal owned or was entitled to those resources. Attackers could substitute another valid numeric ID (IDOR) to read or modify other users' shopping cart contents or personal data.

	\textbf{CWE Explanation}: CWE-639 occurs when an application authorizes a request based solely on a user-controlled key (such as a record ID) instead of confirming the requester is permitted to access the referenced object, enabling horizontal privilege escalation (Insecure Direct Object Reference).

	\textbf{Severity}: High

\subsection{Vulnerability Locations and Type}
\begin{itemize}
	\item \textbf{Cart REST endpoints}: \texttt{/carts/by-customer/{customerId}}, \texttt{/carts/{cartId}/items}, \texttt{/carts/{cartId}/add-item}, \texttt{/carts/{cartId}/remove-item/{itemId}}, and \texttt{/carts/{cartId}/total-price} accepted arbitrary path IDs; prior to fixes there was no binding between these IDs and the authenticated user (classic IDOR / horizontal escalation).
	\item \textbf{Cart item endpoint}: \texttt{/cart-items/{id}} exposed individual cart items without verifying ownership (permitting enumeration of other users' items by ID).\newline
	\item \textbf{Customer lookup endpoints}: \texttt{/customers/{id}} and \texttt{/customers/by-username/{username}} allowed retrieval of other customers' personal information without ownership check (in early state) relying only on being authenticated.
\end{itemize}

\subsection{Mitigation Strategy and Rationale}
The strategy focused on eliminating trust in client-supplied identifiers by: (1) performing \textbf{server-side ownership validation} after object retrieval, (2) layering \textbf{role checks} so only admins can enumerate accounts, and (3) reducing exposed data via DTOs. Ownership checks ensure an attacker who guesses an ID still receives \texttt{403 Forbidden} (or \texttt{404 Not Found}) unless authorized. This halts horizontal privilege escalation while preserving legitimate functionality for rightful owners.

\subsection{Implemented Security Controls}
\begin{enumerate}
	\item \textbf{Ownership helpers}: Introduced methods \texttt{enforceCustomerOwnership(...)} and \texttt{resolvedOwnedCart(...)} in the cart controller to load the resource and verify \texttt{resource.owner.username == principal.username} before returning it.
	\item \textbf{Cart item deletion hardening}: Added explicit retrieval and cart-to-item linkage verification before deleting an item, ensuring the item belongs to the authenticated user's cart, preventing cross-cart deletions.
	\item \textbf{Principal injection}: Added \texttt{@AuthenticationPrincipal} parameters to affected controller methods to reliably access the authenticated identity rather than relying on user-provided IDs.
	\item \textbf{Customer data protection}: Added central ownership/admin check (\texttt{enforceOwnershipOrAdmin}) to customer endpoints and restricted full listing to \texttt{ADMIN} via \texttt{@PreAuthorize}.
	\item \textbf{Least privilege for enumeration}: Restricted \texttt{/users/**} and customer listing endpoints to \texttt{ADMIN} in \texttt{SecurityConfig}, removing the ability for regular users to guess IDs and enumerate.
	\item \textbf{DTO redaction}: Replaced direct entity exposure with DTOs omitting password hashes, limiting the value of any accidental disclosure.
	\item \textbf{Path-based + method security}: Retained path restrictions (role-based) and enabled method-level security, adding a secondary barrier should future path patterns broaden inadvertently.
\end{enumerate}

\subsection{Solution Effectiveness}
\begin{itemize}
	\item Ownership enforcement turns previously unauthenticated resource selection into a two-factor authorization (valid ID + rightful owner) neutralising ID guessing.
	\item Removal operations now validate item-to-cart ownership, closing a residual destructive IDOR vector.
	\item Admin-only enumeration eliminates bulk discovery of valid identifiers (reducing reconnaissance surface).
	\item DTO redaction ensures that even if an ownership check regresses, sensitive credential data remains undisclosed.
	\item Layered (config + method) checks reduce single-point-of-failure risk if URL matcher misconfiguration reappears.
\end{itemize}

\section{CWE-384: Session Fixation}

	\textbf{Description}: Initially the session fixation risk was assessed because the configuration did not explicitly state a session fixation protection strategy, and CSRF protection was disabled (increasing the impact of any session hijacking). However, Spring Security's default behaviour already migrates (rotates) the session identifier upon successful authentication. We have now made this protection explicit in the security configuration, confirming that an attacker who pre-seeds a victim with a known anonymous session ID cannot continue to use that same ID after the victim authenticates.

	\textbf{CWE Explanation}: CWE-384 (Session Fixation) concerns failure to invalidate or regenerate a session identifier when a user's authentication state changes, enabling an attacker who knows the pre-auth session token to hijack the post-auth session.

	\textbf{Severity}: Low (Residual) – Effective mitigations in place; only hardening items remain.

\subsection{Vulnerability Locations and Type}
Prior to the explicit mitigation the potential exposure was theoretical rather than an observed exploit, characterised by:
\begin{itemize}
	\item No explicit session fixation directive in \texttt{SecurityConfig} (relying implicitly on framework defaults).\newline
	\item Disabled CSRF protection (would amplify damage of any successful fixation / hijack).\newline
	\item Absence of cookie security attribute configuration (Secure / SameSite / HttpOnly not yet declared in \texttt{application.properties}).
\end{itemize}
Crucially, there was \emph{no} custom code overriding Spring Security's default fixation protection; thus the core exploit path (reusing the same session ID after login) was already blocked.

\subsection{Mitigation Strategy and Rationale}
Strategy focused on: (1) making implicit framework protections \emph{explicit} for auditability, (2) reducing residual attack surface through planned cookie hardening and CSRF re-enablement, and (3) documenting session handling to prevent future regressions (e.g. switching to a stateless policy without compensating controls). Explicit configuration eliminates uncertainty for reviewers and compliance checks.

\subsection{Implemented Security Controls}
\begin{enumerate}
	\item \textbf{Explicit session ID migration}: Added \texttt{sessionFixation(migrateSession())} under \texttt{sessionManagement} in \texttt{SecurityConfig}, guaranteeing a new session identifier post-authentication.
	\item \textbf{Logout invalidation}: Existing logout configuration invalidates the session server-side, preventing reuse of an authenticated context.
	\item \textbf{Least privilege hardening elsewhere}: Reduced horizontal/vertical escalation (CWE-284 / CWE-639 controls) lowers the value of any hypothetical hijacked session.
	\item \textbf{Password hashing (BCrypt)}: Limits credential replay even if a session were short-livedly exposed.
\end{enumerate}

\subsection{Solution Effectiveness}
\begin{itemize}
	\item Attacker-controlled pre-auth session IDs are invalidated because the server issues a fresh session ID upon authentication (session fixation vector neutralised).
	\item Logout and privilege boundaries ensure compromised sessions cannot silently escalate or persist indefinitely.
	\item Strengthened access controls reduce the actionable scope of any transient session misuse.
	\item Making the protection explicit aids code reviews and prevents accidental regression (e.g. future refactor removing defaults unnoticed).
\end{itemize}

Given the default and now explicit migration behaviour, the application is not meaningfully vulnerable to session fixation at present; residual items are advisory enhancements.


\chapter{A02:2021 Cryptographic Failures}

\section{CWE-311: Missing Encryption of Sensitive Data}

	\textbf{Description}: Certain sensitive data flows in the BookShop application lack enforced cryptographic protection in transit or rely on plaintext representation in local configuration. While user passwords are securely hashed (BCrypt) and the application--database channel is configured for SSL, end-user credential submission (login/registration), session cookies, and ad hoc sensitive form fields (e.g. checkout credit card input) can traverse unencrypted HTTP if the deployment is not fronted by TLS. Additionally, example environment variables and scripts illustrate plaintext storage of database and truststore secrets. These gaps collectively represent incomplete protection of sensitive data rather than a single critical exposure.

	\textbf{CWE Explanation}: CWE-311 refers to missing or absent encryption for sensitive information either at rest or in transit where encryption is expected for confidentiality or regulatory compliance. It commonly manifests as cleartext transmission (overlaps with CWE-319) or cleartext storage (overlaps with CWE-312 / CWE-256) when mitigations are inconsistent or absent.

	\textbf{Severity}: Medium (Residual) -- Core credentials (passwords at rest) are protected; remaining issues affect transport and secret handling hygiene.

\subsection{Vulnerability Locations and Type}
\begin{itemize}
	\item \textbf{Transport (HTTP)}: Application lacks explicit HTTPS / TLS configuration (no \texttt{server.ssl.*}); README usage examples employ \texttt{http://localhost:8080}. In any non-local deployment without a reverse proxy TLS terminator, credentials and session cookies would be transmitted in cleartext (CWE-319 contributing to CWE-311).
	\item \textbf{Session Cookies}: No Secure, HttpOnly, or SameSite attributes configured; cookies could be exposed over insecure transport or be susceptible to CSRF replay.
	\item \textbf{Checkout form data}: Credit card number field (not persisted) is still transmitted; without TLS it is exposed in transit. No masking or client-side obfuscation.
	\item \textbf{Secrets in environment artifacts}: Example \texttt{.env} content and setup scripts contain plaintext database credentials and truststore password (acceptable for local dev, but a risk pattern if replicated to production). Overlaps with CWE-256.
	\item \textbf{Logging / auditing}: No explicit masking safeguards (currently no evidence of leakage, but absence of policy introduces latent risk if future logging is added).
\end{itemize}

\subsection{Mitigation Strategy and Rationale}
Strategy targets layered confidentiality protection: (1) enforce TLS for all external HTTP traffic; (2) harden session cookie attributes to reduce exposure and replay potential; (3) minimise plaintext secret footprint by moving production secrets to a managed vault; (4) restrict network attack surface via HSTS and secure redirects; (5) avoid collecting unnecessary high sensitivity data (drop credit card field if not processing payments). This layered defence ensures compromise of any single mechanism (e.g. proxy misconfiguration) does not fully expose sensitive data.

\subsection{Implemented / Planned Security Controls}
\begin{enumerate}
	\item \textbf{Password hashing (in place)}: All user credentials stored with BCrypt (adaptive hashing, salts implicit) -- removes cleartext password storage risk.
	\item \textbf{Encrypted DB channel (in place)}: JDBC URL enforces \texttt{useSSL=true} and \texttt{requireSSL=true} with truststore configuration.
	\item \textbf{Session fixation mitigation (in place)}: Protects session integrity post-auth (limits utility of intercepted pre-auth IDs).
	\item \textbf{Planned TLS enforcement}: Introduce reverse proxy or Spring Boot keystore; redirect HTTP\;$\rightarrow$\;HTTPS and add HSTS header.
	\item \textbf{Cookie hardening (planned)}: Set \texttt{server.servlet.session.cookie.secure=true}, \texttt{...http-only=true}, \texttt{...same-site=Strict}.
	\item \textbf{Secret management (planned)}: Replace plaintext env variables (especially root DB password) with secrets provisioned by a secure store (Vault / cloud KMS) and principle of least privilege DB accounts.
	\item \textbf{Data minimisation (planned)}: Remove or tokenise credit card field; if retained for demo, clearly flag as non-production and mask client-side.
	\item \textbf{Logging safeguards (planned)}: Introduce logging policy and filters to prevent future accidental sensitive data logging.
\end{enumerate}

\subsection{Solution Effectiveness}
\begin{itemize}
	\item Existing strong password hashing and encrypted DB transport already neutralise the most damaging storage and backend transit risks.
	\item Planned universal TLS and Secure/HttpOnly/SameSite cookies will close interception windows for credentials and session tokens.
	\item Secret manager adoption will reduce blast radius of host compromise or repo leakage versus static env files.
	\item Removing unnecessary high sensitivity fields (credit card) eradicates an entire sensitive data class, lowering compliance scope (PCI DSS) and exposure.
	\item Layered controls ensure that even if one layer (e.g. proxy TLS) fails, credential hashes remain non-reversible and session tokens protected by cookie policies.
\end{itemize}

\section{CWE-315: Cleartext Storage of Sensitive Information in a Cookie}

	\textbf{Description}: Analysis confirms no sensitive information (plaintext passwords, API keys, tokens containing secrets, PII, payment data) is stored in browser cookies. The application relies exclusively on the standard opaque \texttt{JSESSIONID} for server-side session tracking. No custom cookie creation exists in server code or client-side JavaScript; thus the application is \emph{not currently vulnerable} to CWE-315.

	\textbf{CWE Explanation}: CWE-315 covers placing sensitive information directly (cleartext or trivially encoded) into cookies such that disclosure or tampering enables account compromise, impersonation, or data leakage. Even with HTTPS, client-side storage of secrets is discouraged because local access or XSS can expose them.

	\textbf{Severity}: None (Not Vulnerable). Would elevate to High if future changes store secrets (e.g. raw bearer tokens) in cookies without encryption/integrity safeguards.

\subsection*{Assessment Evidence}
\begin{itemize}
	\item No occurrences of custom \texttt{Cookie} creation or header manipulation in Java sources.
	\item No \texttt{document.cookie} usage in static JS or templates.
	\item DTOs exclude password hashes; no credential material leaves server to be placed in cookies.
	\item Session identifier is opaque; no sensitive claims or data embedded.
\end{itemize}

\subsection*{Mitigation Strategy and Rationale}
Maintain a minimal opaque session token model: keep all sensitive state server-side; never persist secrets or PII in client cookies. Complement with cookie attribute hardening (Secure, HttpOnly, SameSite) and session rotation (already explicit) to reduce ancillary risks (CWE-614, CWE-1275) while ensuring no CWE-315 condition can emerge inadvertently.

\subsection*{Implemented / Planned Controls}
\begin{enumerate}
	\item \textbf{Opaque server session (implemented)}: Only an identifier stored client-side.
	\item \textbf{Password hashing (implemented)}: Removes any need to surface plaintext credentials.
	\item \textbf{No custom cookie writes (implemented)}: Eliminates common accidental leakage vector.
	\item \textbf{Cookie attribute hardening (planned)}: Add Secure / HttpOnly / SameSite (ties into CWE-319 remediation).
	\item \textbf{Future guardrails (planned)}: CI/static rule to flag introduction of sensitive keywords in cookie names or values.
\end{enumerate}

\subsection*{Solution Effectiveness}
\begin{itemize}
	\item Absence of data-bearing cookies removes primary CWE-315 attack surface.
	\item Planned attributes further reduce residual token theft or cross-site replay vectors.
	\item Guardrails lower regression risk if new auth features (remember-me, JWT) are introduced.
\end{itemize}


\section{CWE-319: Cleartext Transmission of Sensitive Information}

	\textbf{Description}: Client-server interactions (login, registration, authenticated browsing) were originally performed over HTTP with no transport security enforcement, as neither embedded TLS (no \texttt{server.ssl.*} properties) nor an HTTPS redirect existed. Documentation curl examples referenced \texttt{http://localhost:8080}, normalising plaintext usage. In any non-local / shared network scenario this exposes credentials and session identifiers to interception or manipulation (Man-in-the-Middle, passive sniffing). Session cookies also lacked Secure / SameSite attributes, increasing replay and cross-site leakage risk.

	\textbf{CWE Explanation}: CWE-319 addresses transmission of sensitive information over cleartext channels. Attackers positioned on the network path can read or alter traffic lacking cryptographic protection. This differs from CWE-311 (broader missing encryption) by focusing specifically on in-transit confidentiality/integrity compromise enabling credential theft, session hijacking, or data tampering.

	\textbf{Severity}: High (production / shared networks). Medium (loopback-only development) but still a negative security practice.

\subsection*{Vulnerability Locations and Type}
\begin{itemize}
	\item \textbf{No TLS configuration}: Absence of \texttt{server.ssl.key-store} or reverse proxy mandate meant HTTP only.
	\item \textbf{No enforcement}: Security configuration had no channel security requirement or redirect to HTTPS.
	\item \textbf{Session cookies}: Lacked Secure, HttpOnly, SameSite flags (susceptible to interception / CSRF replay once over HTTP).
	\item \textbf{Documentation examples}: README exclusively used plaintext HTTP endpoints, encouraging insecure operational patterns.
	\item \textbf{Potential sensitive forms}: Payment / PII form submissions (if added) would likewise traverse HTTP.
\end{itemize}

\subsection*{Mitigation Strategy and Rationale}
Enforce an \textit{HTTPS by default} posture: (1) introduce production-profile HTTPS enforcement and HSTS to prevent downgrade, (2) configure TLS via keystore or proxy, (3) harden cookies (Secure, HttpOnly, SameSite) reducing token exfiltration surface, (4) eliminate plaintext examples to shift developer behaviour, (5) add automated tests verifying redirect + security headers to prevent regression. Layered approach ensures that if a single control fails (e.g. misconfigured proxy), other safeguards (cookie flags, credential hashing) limit exploit value.

\subsection*{Implemented / Planned Security Controls}
\begin{enumerate}
	\item \textbf{Prod profile HTTPS enforcement (implemented)}: Added custom redirect filter + HSTS headers when \texttt{prod} profile active.
	\item \textbf{HSTS (implemented prod)}: Sets long max-age with subdomain + preload intent to resist protocol downgrades.
	\item \textbf{Password hashing (existing)}: Mitigates offline cracking impact if credentials were previously observed.
	\item \textbf{Cookie hardening (planned)}: Add \texttt{server.servlet.session.cookie.secure=true}, \texttt{...http-only=true}, \texttt{...same-site=Strict}.
	\item \textbf{TLS keystore / proxy integration (planned)}: Provide keystore properties or documented reverse proxy termination (NGINX / Caddy with ACME).
	\item \textbf{Documentation update (planned)}: Replace HTTP examples with HTTPS and describe trusting dev self-signed cert.
	\item \textbf{Automated tests (planned)}: Integration test asserting HTTP -> HTTPS 301/308 redirect and presence of HSTS in prod.
	\item \textbf{Mixed content audit (planned)}: Validate no HTTP asset references remain post-transition.
\end{enumerate}

\subsection*{Solution Effectiveness}
\begin{itemize}
	\item HTTPS enforcement + HSTS removes primary interception vector (passive sniffing / trivial MiTM downgrade).
	\item Cookie hardening will prevent session token leakage over inadvertent HTTP calls and reduce CSRF token reuse potential.
	\item Removing plaintext examples reduces operational drift toward insecure defaults.
	\item Automated testing creates a guardrail against accidental removal of channel security.
	\item Existing password hashing ensures historical captures have limited utility if obtained pre-mitigation.
\end{itemize}


\section{CWE-256: Unprotected Storage of Credentials}

	\textbf{Description}: Core user credentials (passwords) are securely stored using BCrypt hashing; however, residual unprotected credential storage issues remain: (1) a default administrator password is disclosed in cleartext inside the seeding script comments, (2) database and truststore secrets are managed as plaintext environment variables in a local \texttt{.env} file and referenced directly by docker compose, and (3) weak placeholder values are demonstrated in README examples. These patterns risk accidental promotion of development secrets or reuse of weak defaults in production. The issue is thus not plaintext password storage in the database, but exposure and handling of operational secrets and a hard-coded default credential pattern.

	\textbf{CWE Explanation}: CWE-256 covers storing credentials without adequate protection (encryption, hashing, vault-based segregation) or exposing them in source artifacts (scripts, config files, comments) such that compromise of the repository or workstation yields immediate credential disclosure. It overlaps with CWE-798 (hard-coded credentials) when defaults are embedded, and with CWE-522 when credential protection mechanisms are insufficient.

	\textbf{Severity}: Medium (would escalate toward High if the disclosed admin password or example secrets were deployed unchanged beyond local development).

\subsection*{Vulnerability Locations and Type}
\begin{itemize}
		\item \textbf{Seed script comment}: \texttt{scripts/create-admin-user.sql} contains a cleartext default admin password in a comment (hard-coded / discoverable credential pattern).
		\item \textbf{Environment variables}: \texttt{.env} (excluded from VCS, but encouraged) stores DB root/user passwords and truststore password in plaintext. Acceptable locally, but no segregation or rotation policy specified for higher environments.
		\item \textbf{Truststore password exposure}: Passed directly via \texttt{SPRING\_DATASOURCE\_HIKARI\_TRUSTSTORE\_PASSWORD} environment variable; resident in process environment and potentially logs if misconfigured.
		\item \textbf{Placeholder weak values}: README examples (\texttt{rootpassword}, \texttt{appuserpassword}, \texttt{truststorepassword}) risk being reused verbatim.
	\item \textbf{No secret scanning / policy}: CI/CD pipeline (not documented) lacks automated detection to block accidental secret commits.
\end{itemize}

\subsection*{Mitigation Strategy and Rationale}
Focus on eliminating static/discoverable secrets in source and strengthening operational handling: (1) remove or parameterise default credentials; (2) introduce secret generation at setup time with one-time display; (3) adopt a secrets manager for non-local deployments; (4) enforce least-privilege DB accounts (separate admin vs app user); (5) integrate automated secret scanning to prevent regressions; (6) clearly label placeholder values as `CHANGEME` to discourage reuse. This reduces credential exposure surface and shortens compromise window via rotation and principle of least privilege.

\subsection*{Implemented / Planned Security Controls}
\begin{enumerate}
	\item \textbf{Password hashing (implemented)}: All end-user passwords stored using BCrypt (adaptive, salted) eliminating plaintext password-at-rest risk.
	\item \textbf{DTO redaction (implemented)}: Password hashes no longer returned by any API endpoints, reducing secondary leakage channels.
	\item \textbf{Encrypted DB transport (implemented)}: Mitigates interception of database credentials post-auth handshake.
	\item \textbf{Remove default admin secret (planned)}: Replace hard-coded admin credential comment with instruction to supply a strong password (or script-driven random generation).
	\item \textbf{Secret generation (planned)}: Modify setup scripts to auto-generate strong random passwords (e.g. 24+ char base64) and print once.
	\item \textbf{Secrets manager integration (planned)}: Externalise production secrets (Vault / cloud provider store) removing reliance on persistent `.env` in production.
	\item \textbf{Least privilege DB accounts (planned)}: Separate schema migration/admin from runtime application user; restrict privileges to required CRUD.
	\item \textbf{Secret scanning in CI (planned)}: Add tools (e.g. Gitleaks / TruffleHog) to detect accidental commits of secrets or weak defaults.
		\item \textbf{Documentation hardening (planned)}: Mark all sample credentials as \texttt{CHANGEME\_<PURPOSE>} to prevent reuse in non-local deployments.
\end{enumerate}

\subsection*{Solution Effectiveness}
\begin{itemize}
	\item Existing hashing already neutralises the most severe impact vector (direct theft of user passwords from DB).
	\item Removing the disclosed admin password and auto-generating credentials eliminates a trivial, high-impact compromise path.
	\item Secrets manager + least privilege narrows lateral movement after host compromise: stolen app credential yields only scoped DB access.
	\item CI secret scanning provides early detection and prevents regression (shift-left control).
	\item Clear CHANGEME placeholders reduce likelihood of weak default propagation to production.
\end{itemize}

\chapter{A03:2021 Injection}


\section{CWE-89: SQL Injection}

	\textbf{Description}: Assessment of the BookShop application's data-access layer found no exploitable SQL Injection vectors in its current state. All persistence operations are performed through Spring Data JPA repository interfaces using method-name derived queries (e.g. \texttt{findByUsername}) or inherited CRUD methods. There is no evidence of string concatenation to build JPQL/SQL, no usage of \texttt{@Query} with interpolated parameters, and no raw JDBC / native query execution paths. Consequently, untrusted user input is never directly merged into executable SQL without parameter binding.

	\textbf{CWE Explanation}: CWE-89 (SQL Injection) arises when an application constructs SQL statements by directly embedding untrusted input, allowing attackers to alter query structure (e.g. changing WHERE clauses, UNION extraction, or triggering stacked queries in permissive drivers). Proper parameterisation ensures user data is treated strictly as values, not executable syntax.

	\textbf{Severity}: None (Not Vulnerable) at present. Would elevate rapidly to High if future features introduce unparameterised dynamic queries.


\subsection*{Assessment Evidence}
Audit activities and findings:
\begin{itemize}
 \item Grep searches for raw SQL construction indicators returned no matches: patterns \texttt{createNativeQuery}, \texttt{@Query}, \texttt{PreparedStatement}, \texttt{Statement}, direct SQL keywords (SELECT/INSERT/UPDATE/DELETE) absent from code except in comments.
 \item No repository methods annotated with \texttt{@Query}; only Spring Data derived query methods (e.g. \texttt{findByUsername}) which use prepared parameter binding under the hood.
 \item No usage of \texttt{EntityManager}, \texttt{JdbcTemplate}, Criteria API, or manual pagination/sorting parameters that could introduce unsafe field injection.
 \item No dynamic ORDER BY / filtering logic sourced from request parameters (no \texttt{Sort} / \texttt{Pageable} occurrences) that could later encourage string concatenation.
 \item Domain entities contain only mapped fields; user-supplied values become parameters in prepared statements generated by the JPA provider (Hibernate), not concatenated SQL fragments.
\end{itemize}


\subsection*{Mitigation Strategy and Rationale}
Maintain a \textit{parameterisation-only} data access pattern and introduce guardrails so future changes cannot silently introduce injection risk. Emphasise: (1) exclusive use of Spring Data method derivation or \texttt{@Query} with named / positional parameters, (2) strict white-listing of sortable / filterable fields when adding dynamic search endpoints, and (3) code review / CI rules to flag raw SQL introduction.

\subsection*{Implemented / Planned Controls}
\begin{enumerate}
 \item \textbf{Spring Data repositories (implemented)}: Auto-generated prepared statements ensure parameter binding.
 \item \textbf{No raw SQL / native queries (implemented)}: Eliminates primary injection surface.
 \item \textbf{Input validation (partial)}: Bean validation (@NotBlank) constrains some inputs; while not a primary defence for injection, it reduces anomalous payload shapes.
 \item \textbf{Repository pattern adherence (planned guardrail)}: Architectural decision record (ADR) to codify prohibition of ad hoc JDBC unless justified with security review.
 \item \textbf{Static scan rule (planned)}: CI grep / SAST rule to flag introduction of \texttt{@Query("\%" + var)} style concatenations or \texttt{createNativeQuery}.
 \item \textbf{Dynamic sort/filter sanitisation (planned)}: If future endpoints accept field names, implement white-list mapping (enum -> column) to avoid direct trust in request parameters.
 \item \textbf{Security review checklist (planned)}: Mandatory review item for any PR adding raw SQL, native queries, or criteria builder logic.
\end{enumerate}


\subsection*{Solution Effectiveness}
\begin{itemize}
 \item Absence of raw or annotated custom queries removes typical injection entry points.
 \item Hibernate's prepared statement generation enforces separation of code and data, neutralising payloads containing quotes or control tokens.
 \item Planned guardrails reduce regression risk as feature scope expands (search, reporting, analytics).
 \item White-list driven future dynamic sorting/filtering prevents second-order injection through column / direction parameters.
\end{itemize}


\section{CWE-20: Improper Input Validation}

	\textbf{Description}: The application previously accepted numerous user-controlled inputs (registration data, cart item quantities, book metadata, author names, payment form field) without comprehensive server-side validation. Only sparse annotations (e.g. \texttt{NotBlank}) existed on a subset of entity fields and were inconsistently enforced (many controller endpoints lacked \texttt{Valid}). This gap allowed malformed, extreme, or semantically invalid values (negative or enormous quantities, impossible years, invalid ISBNs, oversized strings) to reach persistence and business logic layers, risking data integrity degradation, logic manipulation, and denial-of-service via oversized payloads. Recent changes introduced structured DTOs and Bean Validation constraints to close these vectors.

	\textbf{CWE Explanation}: CWE-20 (Improper Input Validation) arises when an application fails to define and enforce syntactic, semantic, or range constraints on externally supplied data before use. Inadequate validation can cascade into numerous secondary weaknesses (injection, overflow, business rule abuse) by allowing maliciously crafted input to impact data stores, processing logic, or downstream APIs.

	\textbf{Severity}: Medium (Residual Low after implemented controls)  Core validation now present; remaining exposure relates to legacy MVC form bindings and unvalidated optional fields slated for refactor.

\subsection*{Vulnerability Locations and Type}
\begin{itemize}
	\item \textbf{Entity direct binding}: Controllers bound domain entities (e.g. \texttt{Customer}, \texttt{Book}) directly from request bodies or form submissions, inheriting every writable field without a whitelist.
	\item \textbf{Missing range/format constraints}: No length or pattern enforcement for ISBN, phone numbers, names, addresses; numeric fields permitted negative or extreme values (price, quantity, year, numberOfCopies).
	\item \textbf{Quantity manipulation}: Cart add-item accepted arbitrary (including zero/negative) quantities enabling inventory or pricing anomalies.
	\item \textbf{Payment form}: Credit card number field had no format, length, or checksum validation (and is non-functional demo data).
	\item \textbf{Silent extra fields}: Jackson deserialization accepted unknown JSON properties (risk of future mass assignment if sensitive setters are added).
\end{itemize}

\subsection*{Mitigation Strategy and Rationale}
Adopt a defence-in-depth input sanitation model: (1) Introduce dedicated request DTOs with explicit whitelists and Bean Validation annotations; (2) Apply semantic, syntactic, and range constraints (regex, size, numeric bounds); (3) Enforce validation by annotating controller method parameters with \texttt{@Valid}; (4) Fail fast with a consistent error contract via a global exception handler; (5) Harden deserialization to reject unknown properties, preventing accidental acceptance of stray or future-sensitive fields. This systematic approach ensures only well-formed, business-compliant data continues beyond the controller boundary.


\subsection*{Implemented Security Controls}
\begin{enumerate}
	\item \textbf{CustomerRegistrationDto  Bean Validation}: Username, password, personal and contact fields now constrained with length, pattern, and format annotations (e.g. \texttt{Email}, phone regex) and enforced through \texttt{Valid}.
	\item \textbf{Book field constraints}: Added size, ISBN pattern (ISBN-10/13), year range (1450–2100), non-negative price with scale check, and bounded copy counts.
	\item \textbf{Cart add-item validation}: Quantity now requires minimum 1 (\texttt{Min(1)}), preventing negative or zero-impact manipulations.
	\item \textbf{Global validation handler}: Central \texttt{ControllerAdvice} standardises 400 responses and prevents verbose default error leakage.
	\item \textbf{Strict deserialization}: \texttt{spring.jackson.deserialization.fail-on-unknown-properties true} rejects payload fields not explicitly declared in DTOs, blocking silent mass-assignment style expansion.
	\item \textbf{Password hashing continuity}: Ensures even validated credential inputs are irreversibly stored (complements validation by preserving confidentiality).
	\item \textbf{Field renaming hygiene}: Normalised \texttt{bookName} naming to prevent tooling / lint confusion and encourage consistent property-level validation.
\end{enumerate}


\subsection*{Planned / Remaining Controls}
\begin{itemize}
	\item Introduce DTOs and validation for MVC Book/Author form submissions to replace direct entity binding.
	\item Add validation (or removal) of the demo credit card field with checksum (Luhn) if retained.
	\item Enforce maximum aggregate payload sizes at reverse proxy and apply additional per-field size caps where user-generated text is later introduced.
	\item Add rate limiting (ties to CWE-799) to reduce brute-force probing of validation boundaries.
	\item Add automated tests asserting rejection of malformed ISBNs, negative quantities, overlong fields.
	\item Implement business rule validators (e.g. inventory non-negative after operations) as custom constraints or service assertions.
\end{itemize}


\subsection*{Solution Effectiveness}
\begin{itemize}
	\item \textbf{Whitelisting DTOs}: Replaces broad entity binding with curated inputs, eliminating inadvertent exposure of internal or future sensitive fields (prevents mass assignment class of CWE-20 derived issues).
	\item \textbf{Bean Validation enforcement}: Declarative constraints ensure malformed data is rejected pre-persistence, safeguarding data integrity and reducing attack surface for logic abuse or cascading injection vectors.
	\item \textbf{Semantic constraints}: ISBN regex, numeric bounds, and size limits prevent structurally invalid data that could otherwise fuel business logic anomalies or storage bloat.
	\item \textbf{Fail-fast error handling}: Consistent 400 responses shrink observability for attackers attempting boundary probing (no stack traces or partial processing side-effects).
	\item \textbf{Unknown property rejection}: Blocks introduction of rogue fields trying to smuggle unexpected values, a common foothold for privilege inflation or latent injection when new setters appear.
	\item \textbf{Quantity constraints}: Prevent negative or zero manipulations that could be leveraged to produce free/credit scenarios or integer underflow in future calculations.
	\item \textbf{Normalization \& naming hygiene}: Clear, conventional field naming supports static analysis and future automated policy checks, reducing misconfiguration risk.
\end{itemize}


\section{CWE-79: Cross-Site Scripting (XSS)}

	\textbf{Description}: A structured audit of all server-rendered HTML (Thymeleaf templates under \texttt{src/main/resources/templates}) and relevant controller pathways found \textit{no exploitable Cross-Site Scripting vectors} in the current codebase. All user-controlled fields are emitted via Thymeleaf's escaped expression and form binding mechanisms (e.g. \texttt{th:text}, \texttt{th:field}, attribute processors) which HTML-encode special characters. There is \textbf{no} use of unescaped output primitives (\texttt{th:utext}), inlined JavaScript expression substitutions (\texttt{[[...]]} / \texttt{[(...)]}), or manual string concatenation inserting raw request data into script blocks or event handler attributes. Earlier template refactors (e.g. renaming to \texttt{bookName}) maintained escaped bindings and removed any need for ad hoc unescaped placeholders. Consequently attacker-supplied input cannot break containment to execute script in another user's browser under current functionality.

	\textbf{CWE Explanation}: CWE-79 arises when untrusted input is included in a web page without proper context-aware encoding or sanitisation, enabling the injection and execution of arbitrary script in the victim's browser (reflected, stored, or DOM-based). Preventing XSS requires systematically neutralising user-controlled characters significant to HTML/JS parsing or restricting script execution pathways.

	\textbf{Severity}: None (Not Vulnerable at present). Would elevate if future rich text / HTML features or unescaped rendering are introduced without sanitisation.

\subsection*{Assessment Evidence}
Audit activities and supporting findings:
\begin{itemize}
 \item Grep searches for unescaped constructs returned none: patterns \texttt{th:utext} and inline substitution delimiters \texttt{[[} / \texttt{[(} (used for inlined JS) are absent.
 \item No occurrences of raw output methods or manual HTML string assembly in controllers/services; all views resolved through Thymeleaf templates.
 \item All dynamic textual content rendered with escaping processors (\texttt{th:text}, \texttt{th:value}, \texttt{th:field}); no direct usage of \texttt{th:utext} (which would bypass encoding).
 \item No template inlined JavaScript blocks containing template expressions; only static script includes are present.
 \item No reflection of request parameters into error pages or query string echoes; validation errors are summarised as plain escaped messages via the global handler.
 \item Input validation (length/pattern constraints) reduces payload surface even if an encoding bypass were later introduced.
 \item Template field rename adjustments (\texttt{book\_name} -> \texttt{bookName}) avoided broken bindings that might otherwise tempt unescaped insertions.
\end{itemize}

\subsection*{Mitigation Strategy and Rationale}
Maintain a \textit{strict auto-escape} posture while adding forward-looking guardrails: (1) rely solely on Thymeleaf's escaped output features for plain text; (2) introduce Content Security Policy (CSP) to constrain script execution sources; (3) forbid unescaped directives (\texttt{th:utext}) except under explicit security review with server-side sanitisation; (4) implement lint / CI checks for introduction of risky constructs; (5) if future rich text/user HTML is required, apply a conservative allow-list sanitizer before persistence and still encode on output.

\subsection*{Implemented / Planned Controls}
\begin{enumerate}
 \item \textbf{Escaped template rendering (implemented)}: Exclusive use of \texttt{th:text}, \texttt{th:field}, and attribute processors ensures HTML entity encoding.
 \item \textbf{Absence of unescaped primitives (implemented)}: No \texttt{th:utext} or inline expression substitutions eliminates common bypass channels.
 \item \textbf{No dynamic script construction (implemented)}: No server-sourced data injected into inline \texttt{<script>} blocks or event handler attributes.
 \item \textbf{Input validation (implemented)}: Bean Validation narrows malicious payload shapes (defence-in-depth only).
 \item \textbf{CSP header (planned)}: Add restrictive \texttt{Content-Security-Policy} (e.g. \texttt{script-src 'self'; object-src 'none'; base-uri 'self'; frame-ancestors 'none'}) to mitigate impact if an injection slips through.
 \item \textbf{Template guardrail (planned)}: CI rule / review checklist to flag additions of \texttt{th:utext}, inline script expressions, or event attributes containing untrusted expressions.
 \item \textbf{Rich text sanitisation policy (planned)}: If future features require formatted user content, adopt an allow-list HTML sanitizer (e.g. OWASP Java HTML Sanitizer) prior to storage.
 \item \textbf{Security headers bundle (planned)}: Referrer-Policy, Permissions-Policy, and strengthening cookies (Secure, HttpOnly, SameSite) to reduce session theft avenues in case of future XSS.
\end{enumerate}

\subsection*{Solution Effectiveness}
\begin{itemize}
 \item Auto-escaping neutralises script meta-characters (<, >, \&, quotes) preventing payload interpretation as active markup.
 \item Lack of unescaped or inline script sinks removes primary exploit vectors (no DOM insertion points for attacker data).
 \item Planned CSP provides a containment layer limiting execution even if an HTML injection is discovered later (e.g. blocks external script exfiltration).
 \item Guardrail automation (grep / CI checks) lowers regression risk as templates evolve.
 \item Sanitisation policy planning ensures future feature expansion (rich text) introduces structured controls rather than ad hoc exceptions.
\end{itemize}



\chapter{A04:2021 Insecure Design}


\section{CWE-307: Improper Restriction of Excessive Authentication Attempts}

	\textbf{Description}: The application originally permitted unlimited rapid authentication attempts against the \texttt{/login} endpoint with no per-username or per-IP throttling, enabling brute force, credential stuffing, and password spraying attacks. Attackers could iterate common or leaked credential pairs without delay, increasing account takeover likelihood and aiding enumeration of valid usernames through timing/lockout observation (although failure messages were uniform). This condition constitutes CWE-307 prior to recently implemented controls.

	\textbf{CWE Explanation}: CWE-307 arises when an application fails to enforce limits on repeated authentication attempts (e.g. password, MFA, reset token submissions), allowing automated high-frequency guessing that can compromise accounts or facilitate credential stuffing campaigns. Proper controls (lockout, backoff, rate limiting) reduce the feasible attempt rate and raise detection opportunities.

	\textbf{Severity}: Low (Residual) — Core throttling and lockout controls now implemented; remaining exposure is limited to single-instance memory scope and absence of distributed correlation.

\subsection*{Vulnerability Locations and Type}
\begin{itemize}
	\item \textbf{Login endpoint}: POST \texttt{/login} accepted unlimited sequential failures (no max attempt threshold, delay, or CAPTCHA escalation).
	\item \textbf{Lack of per-identity lockout}: No temporary suspension after repeated incorrect credentials for the same username.
	\item \textbf{Lack of IP spray detection}: No broader rate control for an IP submitting many different usernames (credential stuffing pattern).
	\item \textbf{Absence of central attempt telemetry}: No counters or logs dedicated to failed authentication bursts (reduced detection / alerting capability).
\end{itemize}

\subsection*{Mitigation Strategy and Rationale}
Adopt a layered throttling model combining \textit{pre-auth rejection} (cheap filter), \textit{account/IP scoped lockout}, and \textit{reset on success}: (1) Intercept login requests prior to authentication to block already locked principals (resource preservation); (2) Maintain rolling failure windows and impose temporary locks (discourages brute force); (3) Track both username and source IP to differentiate targeted vs spray attacks; (4) Provide generic error responses to avoid username enumeration; (5) Reset counters on successful authentication to reduce accidental lockouts and user friction. This approach sharply lowers feasible guessing throughput while keeping implementation lightweight.

\subsection*{Implemented / Planned Security Controls}
\begin{enumerate}
	\item \textbf{Failure counting service (implemented)}: \texttt{LoginAttemptService} tracks failures per username (threshold 5 in 15 min) and per IP (threshold 30) and enforces a 10 minute lock via timestamp comparison.
	\item \textbf{Pre-auth rate limiting filter (implemented)}: \texttt{LoginRateLimitingFilter} short-circuits POST \texttt{/login} when a username or IP is locked, returning HTTP 429 (Too Many Requests) without invoking downstream authentication logic.
	\item \textbf{Success / failure handlers (implemented)}: \texttt{AuthenticationHandlers} records failures and clears username attempts upon success, limiting persistent false positives.
	\item \textbf{Uniform error messaging (existing)}: Generic \texttt{/login?error} response avoids disclosing whether the username or password was invalid, reducing enumeration signal.
	\item \textbf{Session fixation protection (existing)}: Complements throttling by ensuring hijacked pre-auth sessions cannot be leveraged mid-brute force.
	\item \textbf{Planned distributed store (planned)}: Externalise counters to Redis or similar for horizontal scaling and shared lock state across instances.
	\item \textbf{Planned anomaly alerting (planned)}: Emit structured security log events (e.g. JSON) for failed attempt spikes to feed SIEM alert rules.
	\item \textbf{Optional adaptive challenges (planned)}: Introduce CAPTCHA or MFA step-up after multiple failures to add friction for automation.
\end{enumerate}

\subsection*{Solution Effectiveness}
\begin{itemize}
	\item \textbf{Throughput reduction}: Lock + 429 response immediately halts further processing after threshold, capping guess attempts per window.
	\item \textbf{Spray mitigation}: Separate IP threshold limits credential stuffing patterns distributing attempts across many usernames.
	\item \textbf{Low overhead}: Early filter rejection conserves CPU and avoids unnecessary password hash comparisons under attack.
	\item \textbf{Reset on success}: Minimises legitimate user friction (no long-lived stale counters) while preserving deterrence for attackers.
	\item \textbf{Scalability path}: Planned move to distributed cache preserves semantics in multi-node deployment, preventing bypass via node cycling.
	\item \textbf{Extensibility}: Architecture supports extension to MFA attempt throttling or account recovery flows using same service abstraction.
\end{itemize}

Current posture: \textit{Not vulnerable in current single-instance context}. Residual risk relates to lack of distributed correlation and absence of automated alerting — both scheduled for future enhancement.


\section{CWE-602: Client-Side Enforcement of Server-Side Security}

\textbf{Description}: The BookShop application implements critical security controls on the client-side instead of the server-side, allowing attackers to bypass authentication, authorization, and input validation by making direct API calls to backend endpoints. The application relies on client-side JavaScript to enforce security policies that should be implemented on the server.

\textbf{CWE Explanation}: CWE-602 occurs when the application implements security controls (authentication, authorization, input validation) on the client-side rather than the server-side, making them easily bypassable by attackers who can make direct HTTP requests to backend endpoints.

\textbf{Severity}: High



\section{CWE-799: Improper Control of Interaction Frequency}

\textbf{Description}: The BookShop application lacks any rate limiting or frequency control mechanisms, allowing unlimited interaction attempts with all endpoints. The application does not implement authentication attempt limits, request throttling, or any protection against brute force attacks, making it vulnerable to automated attacks and resource exhaustion.

\textbf{CWE Explanation}: CWE-799 occurs when the application fails to properly control the frequency of interactions, allowing attackers to make unlimited requests that can lead to brute force attacks, resource exhaustion, and denial of service conditions.

\textbf{Severity}: High



\section{CWE-840: Business Logic Errors}

\textbf{Description}: The BookShop application contains multiple business logic errors that violate fundamental application rules and constraints. These include race conditions in the checkout process, lack of duplicate username validation, client-side price calculation vulnerabilities, and missing order validation rules that can lead to inventory overselling, account confusion, and financial manipulation.

\textbf{CWE Explanation}: CWE-840 occurs when the application fails to properly implement business rules and constraints, allowing attackers to exploit logical flaws in the application's workflow, data validation, and state management to achieve unauthorized outcomes.

\textbf{Severity}: High



\section{CWE-1173: Improper Use of Validation Framework}

\textbf{Description}: The BookShop application completely lacks proper validation framework usage, with no Bean Validation annotations, no @Valid annotations in controllers, and no validation framework dependencies. The application relies solely on minimal client-side validation, allowing malicious or invalid input to bypass security controls and potentially cause data integrity issues, application instability, and security vulnerabilities.

\textbf{CWE Explanation}: CWE-1173 occurs when the application fails to properly use validation frameworks or implements validation incorrectly, allowing invalid or malicious input to bypass security controls, potentially leading to data integrity issues, application instability, and security vulnerabilities.

\textbf{Severity}: High




\chapter{A05:2021 Security Misconfiguration}

\section{CWE-614: Sensitive Cookie in HTTPS Session Without 'Secure' Attribute}

\textbf{Description}: The BookShop application's session cookies (JSESSIONID) are transmitted without the 'Secure' attribute, allowing them to be sent over unencrypted HTTP connections. This vulnerability exposes session tokens to potential interception by attackers through network sniffing, man-in-the-middle attacks, or other network-based attacks.

\textbf{CWE Explanation}: CWE-614 occurs when sensitive cookies are transmitted over insecure channels without proper protection mechanisms, allowing attackers to capture and reuse session tokens to impersonate authenticated users.

\textbf{Severity}: High



\section{CWE-1275: Sensitive Cookie with Improper SameSite Attribute}

\textbf{Description}: The BookShop application's session cookies lack proper SameSite attribute configuration, allowing them to be sent in cross-site requests and enabling various client-side attacks including CSRF.

\textbf{CWE Explanation}: CWE-1275 occurs when cookies are configured without appropriate SameSite restrictions, allowing them to be sent in cross-site requests and enabling various client-side attacks including CSRF.

\textbf{Severity}: High



\section{CWE-693: Protection Mechanism Failure}

\textbf{Description}: The BookShop application includes Spring Security framework but completely disables all protection mechanisms, rendering the security framework ineffective. The application disables CSRF protection, permits all requests without authentication, and fails to implement any of the available security controls, making the protection mechanism completely non-functional.

\textbf{CWE Explanation}: CWE-693 occurs when the application has a protection mechanism in place but fails to use it properly, rendering the security controls ineffective and leaving the application vulnerable to attacks that the protection mechanism was designed to prevent.

\textbf{Severity}: High



\chapter{A06:2021 Vulnerable and Outdated Components}

\section{CWE-269: Improper Privilege Management}

\textbf{Description}: The BookShop application exhibits multiple critical privilege management failures including missing authentication for critical admin functions, inconsistent privilege enforcement across endpoints, complete bypass of Spring Security framework, and lack of ownership verification for user resources. These vulnerabilities enable unauthorized access, privilege escalation, and cross-user data manipulation.

\textbf{CWE Explanation}: CWE-269 occurs when the application fails to properly manage privileges, permissions, and access controls, allowing unauthorized users to access restricted functionality or resources that should be protected by proper authentication and authorization mechanisms.

\textbf{Severity}: Critical



\section{CWE-400: Uncontrolled Resource Consumption}

\textbf{Description}: The BookShop application lacks proper resource management controls including database connection pool limits, session timeout limits, request timeout limits, and memory limits. This vulnerability allows attackers to exhaust system resources through unlimited requests, session creation, and large payload attacks, potentially leading to denial of service conditions.

\textbf{CWE Explanation}: CWE-400 occurs when the application fails to properly control resource consumption, allowing attackers to exhaust system resources such as memory, CPU, database connections, or network bandwidth through unlimited or uncontrolled operations, leading to denial of service conditions.

\textbf{Severity}: High



\chapter{A07:2021 Identification and Authentication Failures}

\section{CWE-287: Improper Authentication}

\textbf{Description}: The BookShop application implements fundamentally flawed authentication mechanisms including plain text password storage, direct password comparison without hashing, weak password policies, and complete absence of authentication security controls. The application stores user credentials in plain text in the database and performs direct string comparison during login, making it vulnerable to complete account compromise and unauthorized access.

\textbf{CWE Explanation}: CWE-287 occurs when the application fails to properly verify the identity of users, implement secure authentication mechanisms, or protect authentication credentials, allowing attackers to bypass authentication controls, compromise user accounts, and gain unauthorized access to sensitive data and functionality.

\textbf{Severity}: Critical


\chapter{Conclusions}

The BookShop application exhibits multiple critical \textbf{OWASP Top 10} vulnerabilities including \textbf{A01: Broken Access Control} (CWE-306, CWE-639, CWE-264), \textbf{A02: Cryptographic Failures} (CWE-326, CWE-522), \textbf{A03: Injection} (CWE-79 - mitigated by React), \textbf{A04: Insecure Design} (CWE-602, CWE-799, CWE-840, CWE-1173), \textbf{A05: Security Misconfiguration} (CWE-614, CWE-1275, CWE-693, CWE-256), \textbf{A06: Vulnerable and Outdated Components} (CWE-269, CWE-400), \textbf{A07: Identification and Authentication Failures} (CWE-287, CWE-384, CWE-521), \textbf{A07: Software and Data Integrity Failures} (CWE-798), and \textbf{A09: Security Logging and Monitoring Failures} (CWE-209). These vulnerabilities enable session hijacking, session fixation attacks, CSRF attacks, unauthorized data access, information disclosure, credential compromise, insufficient credential protection, weak password requirements, client-side security bypass, brute force attacks, resource exhaustion, business logic errors, race conditions, inventory overselling, financial manipulation, improper privilege management, authentication bypass, privilege escalation, uncontrolled resource consumption, denial of service, validation framework bypass, data integrity issues, improper authentication, plain text password storage, hard-coded credentials, and command injection. The application requires comprehensive security remediation including proper input validation, CSP headers, secure session management, session fixation protection, robust authentication controls, secure configuration management, credential protection, password policy implementation, proper logging practices, server-side security enforcement, rate limiting mechanisms, business rule validation, concurrency controls, privilege management, resource management controls, validation framework implementation, password hashing implementation, authentication security controls, secret management implementation, and framework security implementation. Practice these vulnerabilities in WebGoat to build detection and exploitation skills before testing production applications.


%%%%  BIBLIOGRAPHY 
\newpage
\begin{thebibliography}{99}
\bibitem{OWASP:2021} OWASP Foundation. \emph{OWASP Top 10:2021 - The Ten Most Critical Web Application Security Risks}. Available: \url{https://owasp.org/Top10/}.

\bibitem{CWE:1344} MITRE Corporation. \emph{CWE-1344: Use of Externally-Controlled Input to Select Classes or Code ('Unsafe Reflection')}. Available: \url{https://cwe.mitre.org/data/definitions/1344.html}.

\bibitem{MEND:2024} Mend Security. \emph{OWASP Top 10 CWE Coverage Documentation}. Available: \url{https://docs.mend.io/legacy-sast/latest/owasp-top-10-cwe-coverage}.
\end{thebibliography}
\label{endpage}

\end{document}
\end {article}

